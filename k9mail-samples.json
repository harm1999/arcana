{
  "com.fsck.k9": {
    "com.fsck.k9.BaseAccount": [],
    "com.fsck.k9.Clock": [],
    "com.fsck.k9.EmailAddressValidator": []
  },
  "com.fsck.k9.account": {
    "com.fsck.k9.account.AccountCreator": [
      {
        "visibility": "public",
        "simpleName": "getDefaultDeletePolicy(com.fsck.k9.mail.ServerSettings.Type)",
        "qualifiedName": "com.fsck.k9.account.AccountCreator.getDefaultDeletePolicy(com.fsck.k9.mail.ServerSettings.Type)",
        "kind": "method",
        "sourceText": "public static com.fsck.k9.Account.DeletePolicy getDefaultDeletePolicy(com.fsck.k9.mail.ServerSettings.Type type) {\r\n    switch (type) {\r\n        case IMAP :\r\n            {\r\n                return com.fsck.k9.Account.DeletePolicy.ON_DELETE;\r\n            }\r\n        case POP3 :\r\n            {\r\n                return com.fsck.k9.Account.DeletePolicy.NEVER;\r\n            }\r\n        case WebDAV :\r\n            {\r\n                return com.fsck.k9.Account.DeletePolicy.ON_DELETE;\r\n            }\r\n        case SMTP :\r\n            {\r\n                throw new java.lang.IllegalStateException(\"Delete policy doesn't apply to SMTP\");\r\n            }\r\n    }\r\n    throw new java.lang.AssertionError(\"Unhandled case: \" + type);\r\n}",
        "name": "getDefaultDeletePolicy(com.fsck.k9.mail.ServerSettings.Type)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getDefaultPort(com.fsck.k9.mail.ConnectionSecurity,com.fsck.k9.mail.ServerSettings.Type)",
        "qualifiedName": "com.fsck.k9.account.AccountCreator.getDefaultPort(com.fsck.k9.mail.ConnectionSecurity,com.fsck.k9.mail.ServerSettings.Type)",
        "kind": "method",
        "sourceText": "public static int getDefaultPort(com.fsck.k9.mail.ConnectionSecurity securityType, com.fsck.k9.mail.ServerSettings.Type storeType) {\r\n    switch (securityType) {\r\n        case NONE :\r\n        case STARTTLS_REQUIRED :\r\n            {\r\n                return storeType.defaultPort;\r\n            }\r\n        case SSL_TLS_REQUIRED :\r\n            {\r\n                return storeType.defaultTlsPort;\r\n            }\r\n    }\r\n    throw new java.lang.AssertionError(\"Unhandled ConnectionSecurity type encountered: \" + securityType);\r\n}",
        "name": "getDefaultPort(com.fsck.k9.mail.ConnectionSecurity,com.fsck.k9.mail.ServerSettings.Type)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.activity": {
    "com.fsck.k9.activity.K9PreferenceActivity": [],
    "com.fsck.k9.activity.EditIdentity": [
      {
        "visibility": "public",
        "simpleName": "onCreate(android.os.Bundle)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.activity.EditIdentity.onCreate(android.os.Bundle)",
        "sourceText": "@java.lang.Override\r\npublic void onCreate(android.os.Bundle savedInstanceState) {\r\n    super.onCreate(savedInstanceState);\r\n    mIdentity = ((com.fsck.k9.Identity) (getIntent().getSerializableExtra(com.fsck.k9.activity.EditIdentity.EXTRA_IDENTITY)));\r\n    mIdentityIndex = getIntent().getIntExtra(com.fsck.k9.activity.EditIdentity.EXTRA_IDENTITY_INDEX, -1);\r\n    java.lang.String accountUuid = getIntent().getStringExtra(com.fsck.k9.activity.EditIdentity.EXTRA_ACCOUNT);\r\n    mAccount = com.fsck.k9.Preferences.getPreferences(this).getAccount(accountUuid);\r\n    if (mIdentityIndex == (-1)) {\r\n        mIdentity = new com.fsck.k9.Identity();\r\n    }\r\n    setContentView(R.layout.edit_identity);\r\n    /* If we're being reloaded we override the original account with the one\n    we saved\n     */\r\n    if ((savedInstanceState != null) && savedInstanceState.containsKey(com.fsck.k9.activity.EditIdentity.EXTRA_IDENTITY)) {\r\n        mIdentity = ((com.fsck.k9.Identity) (savedInstanceState.getSerializable(com.fsck.k9.activity.EditIdentity.EXTRA_IDENTITY)));\r\n    }\r\n    mDescriptionView = ((android.widget.EditText) (findViewById(R.id.description)));\r\n    mDescriptionView.setText(mIdentity.getDescription());\r\n    mNameView = ((android.widget.EditText) (findViewById(R.id.name)));\r\n    mNameView.setText(mIdentity.getName());\r\n    mEmailView = ((android.widget.EditText) (findViewById(R.id.email)));\r\n    mEmailView.setText(mIdentity.getEmail());\r\n    mReplyTo = ((android.widget.EditText) (findViewById(R.id.reply_to)));\r\n    mReplyTo.setText(mIdentity.getReplyTo());\r\n    // mAccountAlwaysBcc = (EditText)findViewById(R.id.bcc);\r\n    // mAccountAlwaysBcc.setText(mIdentity.getAlwaysBcc());\r\n    mSignatureLayout = ((android.widget.LinearLayout) (findViewById(R.id.signature_layout)));\r\n    mSignatureUse = ((android.widget.CheckBox) (findViewById(R.id.signature_use)));\r\n    mSignatureView = ((android.widget.EditText) (findViewById(R.id.signature)));\r\n    mSignatureUse.setChecked(mIdentity.getSignatureUse());\r\n    mSignatureUse.setOnCheckedChangeListener(new android.widget.CompoundButton.OnCheckedChangeListener() {\r\n        public void onCheckedChanged(android.widget.CompoundButton buttonView, boolean isChecked) {\r\n            if (isChecked) {\r\n                mSignatureLayout.setVisibility(View.VISIBLE);\r\n                mSignatureView.setText(mIdentity.getSignature());\r\n            } else {\r\n                mSignatureLayout.setVisibility(View.GONE);\r\n            }\r\n        }\r\n    });\r\n    if (mSignatureUse.isChecked()) {\r\n        mSignatureView.setText(mIdentity.getSignature());\r\n    } else {\r\n        mSignatureLayout.setVisibility(View.GONE);\r\n    }\r\n}",
        "name": "onCreate(android.os.Bundle)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.activity.AlternateRecipientAdapter": [
      {
        "visibility": "public",
        "simpleName": "getItem(int)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.activity.AlternateRecipientAdapter.getItem(int)",
        "sourceText": "@java.lang.Override\r\npublic com.fsck.k9.view.RecipientSelectView.Recipient getItem(int position) {\r\n    if ((position == com.fsck.k9.activity.AlternateRecipientAdapter.POSITION_HEADER_VIEW) || (position == com.fsck.k9.activity.AlternateRecipientAdapter.POSITION_CURRENT_ADDRESS)) {\r\n        return currentRecipient;\r\n    }\r\n    return recipients == null ? null : getRecipientFromPosition(position);\r\n}",
        "name": "getItem(int)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "bindHeaderView(android.view.View,com.fsck.k9.view.RecipientSelectView$Recipient)",
        "qualifiedName": "com.fsck.k9.activity.AlternateRecipientAdapter.bindHeaderView(android.view.View,com.fsck.k9.view.RecipientSelectView$Recipient)",
        "kind": "method",
        "sourceText": "public void bindHeaderView(android.view.View view, com.fsck.k9.view.RecipientSelectView.Recipient recipient) {\r\n    com.fsck.k9.activity.AlternateRecipientAdapter.RecipientTokenHolder holder = ((com.fsck.k9.activity.AlternateRecipientAdapter.RecipientTokenHolder) (view.getTag()));\r\n    holder.setShowAsHeader(true);\r\n    holder.headerName.setText(recipient.getNameOrUnknown(context));\r\n    if (!android.text.TextUtils.isEmpty(recipient.addressLabel)) {\r\n        holder.headerAddressLabel.setText(recipient.addressLabel);\r\n        holder.headerAddressLabel.setVisibility(View.VISIBLE);\r\n    } else {\r\n        holder.headerAddressLabel.setVisibility(View.GONE);\r\n    }\r\n    com.fsck.k9.activity.compose.RecipientAdapter.setContactPhotoOrPlaceholder(context, holder.headerPhoto, recipient);\r\n    holder.headerPhoto.assignContactUri(recipient.getContactLookupUri());\r\n    holder.headerRemove.setOnClickListener(new android.view.View.OnClickListener() {\r\n        @java.lang.Override\r\n        public void onClick(android.view.View v) {\r\n            listener.onRecipientRemove(currentRecipient);\r\n        }\r\n    });\r\n}",
        "name": "bindHeaderView(android.view.View,com.fsck.k9.view.RecipientSelectView$Recipient)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "newView(android.view.ViewGroup)",
        "qualifiedName": "com.fsck.k9.activity.AlternateRecipientAdapter.newView(android.view.ViewGroup)",
        "kind": "method",
        "sourceText": "public android.view.View newView(android.view.ViewGroup parent) {\r\n    android.view.View view = android.view.LayoutInflater.from(context).inflate(R.layout.recipient_alternate_item, parent, false);\r\n    com.fsck.k9.activity.AlternateRecipientAdapter.RecipientTokenHolder holder = new com.fsck.k9.activity.AlternateRecipientAdapter.RecipientTokenHolder(view);\r\n    view.setTag(holder);\r\n    return view;\r\n}",
        "name": "newView(android.view.ViewGroup)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getView(int,android.view.View,android.view.ViewGroup)",
        "qualifiedName": "com.fsck.k9.activity.AlternateRecipientAdapter.getView(int,android.view.View,android.view.ViewGroup)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic android.view.View getView(int position, android.view.View view, android.view.ViewGroup parent) {\r\n    if (view == null) {\r\n        view = newView(parent);\r\n    }\r\n    com.fsck.k9.view.RecipientSelectView.Recipient recipient = getItem(position);\r\n    if (position == com.fsck.k9.activity.AlternateRecipientAdapter.POSITION_HEADER_VIEW) {\r\n        bindHeaderView(view, recipient);\r\n    } else {\r\n        bindItemView(view, recipient);\r\n    }\r\n    return view;\r\n}",
        "name": "getView(int,android.view.View,android.view.ViewGroup)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "bindItemView(android.view.View,com.fsck.k9.view.RecipientSelectView$Recipient)",
        "qualifiedName": "com.fsck.k9.activity.AlternateRecipientAdapter.bindItemView(android.view.View,com.fsck.k9.view.RecipientSelectView$Recipient)",
        "kind": "method",
        "sourceText": "public void bindItemView(android.view.View view, final com.fsck.k9.view.RecipientSelectView.Recipient recipient) {\r\n    com.fsck.k9.activity.AlternateRecipientAdapter.RecipientTokenHolder holder = ((com.fsck.k9.activity.AlternateRecipientAdapter.RecipientTokenHolder) (view.getTag()));\r\n    holder.setShowAsHeader(false);\r\n    java.lang.String address = recipient.address.getAddress();\r\n    holder.itemAddress.setText(address);\r\n    if (!android.text.TextUtils.isEmpty(recipient.addressLabel)) {\r\n        holder.itemAddressLabel.setText(recipient.addressLabel);\r\n        holder.itemAddressLabel.setVisibility(View.VISIBLE);\r\n    } else {\r\n        holder.itemAddressLabel.setVisibility(View.GONE);\r\n    }\r\n    boolean isCurrent = currentRecipient == recipient;\r\n    holder.itemAddress.setTypeface(null, isCurrent ? android.graphics.Typeface.BOLD : android.graphics.Typeface.NORMAL);\r\n    holder.itemAddressLabel.setTypeface(null, isCurrent ? android.graphics.Typeface.BOLD : android.graphics.Typeface.NORMAL);\r\n    holder.layoutItem.setOnClickListener(new android.view.View.OnClickListener() {\r\n        @java.lang.Override\r\n        public void onClick(android.view.View v) {\r\n            listener.onRecipientChange(currentRecipient, recipient);\r\n        }\r\n    });\r\n    configureCryptoStatusView(holder, recipient);\r\n}",
        "name": "bindItemView(android.view.View,com.fsck.k9.view.RecipientSelectView$Recipient)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "setAlternateRecipientInfo(java.util.List)",
        "qualifiedName": "com.fsck.k9.activity.AlternateRecipientAdapter.setAlternateRecipientInfo(java.util.List)",
        "kind": "method",
        "sourceText": "public void setAlternateRecipientInfo(java.util.List<com.fsck.k9.view.RecipientSelectView.Recipient> recipients) {\r\n    this.recipients = recipients;\r\n    int indexOfCurrentRecipient = recipients.indexOf(currentRecipient);\r\n    if (indexOfCurrentRecipient >= 0) {\r\n        currentRecipient = recipients.get(indexOfCurrentRecipient);\r\n    }\r\n    recipients.remove(currentRecipient);\r\n    notifyDataSetChanged();\r\n}",
        "name": "setAlternateRecipientInfo(java.util.List)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.activity.compose": {
    "com.fsck.k9.activity.compose.AttachmentPresenter": [
      {
        "visibility": "public",
        "simpleName": "onClickAddAttachment(com.fsck.k9.activity.compose.RecipientPresenter)",
        "qualifiedName": "com.fsck.k9.activity.compose.AttachmentPresenter.onClickAddAttachment(com.fsck.k9.activity.compose.RecipientPresenter)",
        "kind": "method",
        "sourceText": "public void onClickAddAttachment(com.fsck.k9.activity.compose.RecipientPresenter recipientPresenter) {\r\n    com.fsck.k9.activity.compose.ComposeCryptoStatus currentCachedCryptoStatus = recipientPresenter.getCurrentCachedCryptoStatus();\r\n    if (currentCachedCryptoStatus == null) {\r\n        return;\r\n    }\r\n    com.fsck.k9.activity.compose.ComposeCryptoStatus.AttachErrorState maybeAttachErrorState = currentCachedCryptoStatus.getAttachErrorStateOrNull();\r\n    if (maybeAttachErrorState != null) {\r\n        recipientPresenter.showPgpAttachError(maybeAttachErrorState);\r\n        return;\r\n    }\r\n    attachmentMvpView.showPickAttachmentDialog(com.fsck.k9.activity.compose.AttachmentPresenter.REQUEST_CODE_ATTACHMENT_URI);\r\n}",
        "name": "onClickAddAttachment(com.fsck.k9.activity.compose.RecipientPresenter)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "addAttachment(android.net.Uri,java.lang.String)",
        "qualifiedName": "com.fsck.k9.activity.compose.AttachmentPresenter.addAttachment(android.net.Uri,java.lang.String)",
        "kind": "method",
        "sourceText": "public void addAttachment(android.net.Uri uri, java.lang.String contentType) {\r\n    if (attachments.containsKey(uri)) {\r\n        return;\r\n    }\r\n    int loaderId = getNextFreeLoaderId();\r\n    com.fsck.k9.activity.misc.Attachment attachment = com.fsck.k9.activity.misc.Attachment.createAttachment(uri, loaderId, contentType);\r\n    addAttachmentAndStartLoader(attachment);\r\n}",
        "name": "addAttachment(android.net.Uri,java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onRestoreInstanceState(android.os.Bundle)",
        "qualifiedName": "com.fsck.k9.activity.compose.AttachmentPresenter.onRestoreInstanceState(android.os.Bundle)",
        "kind": "method",
        "sourceText": "public void onRestoreInstanceState(android.os.Bundle savedInstanceState) {\r\n    actionToPerformAfterWaiting = com.fsck.k9.activity.compose.AttachmentPresenter.WaitingAction.valueOf(savedInstanceState.getString(com.fsck.k9.activity.compose.AttachmentPresenter.STATE_KEY_WAITING_FOR_ATTACHMENTS));\r\n    nextLoaderId = savedInstanceState.getInt(com.fsck.k9.activity.compose.AttachmentPresenter.STATE_KEY_NEXT_LOADER_ID);\r\n    java.util.ArrayList<com.fsck.k9.activity.misc.Attachment> attachmentList = savedInstanceState.getParcelableArrayList(com.fsck.k9.activity.compose.AttachmentPresenter.STATE_KEY_ATTACHMENTS);\r\n    // noinspection ConstantConditions, we know this is set in onSaveInstanceState\r\n    for (com.fsck.k9.activity.misc.Attachment attachment : attachmentList) {\r\n        attachments.put(attachment.uri, attachment);\r\n        attachmentMvpView.addAttachmentView(attachment);\r\n        if (attachment.state == com.fsck.k9.activity.misc.Attachment.LoadingState.URI_ONLY) {\r\n            initAttachmentInfoLoader(attachment);\r\n        } else if (attachment.state == com.fsck.k9.activity.misc.Attachment.LoadingState.METADATA) {\r\n            initAttachmentContentLoader(attachment);\r\n        }\r\n    }\r\n}",
        "name": "onRestoreInstanceState(android.os.Bundle)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "createAttachmentList()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.activity.compose.AttachmentPresenter.createAttachmentList()",
        "sourceText": "public java.util.ArrayList<com.fsck.k9.activity.misc.Attachment> createAttachmentList() {\r\n    java.util.ArrayList<com.fsck.k9.activity.misc.Attachment> result = new java.util.ArrayList<>();\r\n    for (com.fsck.k9.activity.misc.Attachment attachment : attachments.values()) {\r\n        result.add(attachment);\r\n    }\r\n    return result;\r\n}",
        "name": "createAttachmentList()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onClickRemoveAttachment(android.net.Uri)",
        "qualifiedName": "com.fsck.k9.activity.compose.AttachmentPresenter.onClickRemoveAttachment(android.net.Uri)",
        "kind": "method",
        "sourceText": "public void onClickRemoveAttachment(android.net.Uri uri) {\r\n    com.fsck.k9.activity.misc.Attachment attachment = attachments.get(uri);\r\n    loaderManager.destroyLoader(attachment.loaderId);\r\n    attachmentMvpView.removeAttachmentView(attachment);\r\n    attachments.remove(uri);\r\n    listener.onAttachmentRemoved();\r\n}",
        "name": "onClickRemoveAttachment(android.net.Uri)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onSaveInstanceState(android.os.Bundle)",
        "qualifiedName": "com.fsck.k9.activity.compose.AttachmentPresenter.onSaveInstanceState(android.os.Bundle)",
        "kind": "method",
        "sourceText": "public void onSaveInstanceState(android.os.Bundle outState) {\r\n    outState.putString(com.fsck.k9.activity.compose.AttachmentPresenter.STATE_KEY_WAITING_FOR_ATTACHMENTS, actionToPerformAfterWaiting.name());\r\n    outState.putParcelableArrayList(com.fsck.k9.activity.compose.AttachmentPresenter.STATE_KEY_ATTACHMENTS, createAttachmentList());\r\n    outState.putInt(com.fsck.k9.activity.compose.AttachmentPresenter.STATE_KEY_NEXT_LOADER_ID, nextLoaderId);\r\n}",
        "name": "onSaveInstanceState(android.os.Bundle)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onActivityResult(int,int,android.content.Intent)",
        "qualifiedName": "com.fsck.k9.activity.compose.AttachmentPresenter.onActivityResult(int,int,android.content.Intent)",
        "kind": "method",
        "sourceText": "public void onActivityResult(int resultCode, int requestCode, android.content.Intent data) {\r\n    if (requestCode != com.fsck.k9.activity.compose.AttachmentPresenter.REQUEST_CODE_ATTACHMENT_URI) {\r\n        throw new java.lang.AssertionError(\"onActivityResult must only be called for our request code\");\r\n    }\r\n    if (resultCode != android.app.Activity.RESULT_OK) {\r\n        return;\r\n    }\r\n    if (data == null) {\r\n        return;\r\n    }\r\n    addAttachmentsFromResultIntent(data);\r\n}",
        "name": "onActivityResult(int,int,android.content.Intent)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "checkOkForSendingOrDraftSaving()",
        "qualifiedName": "com.fsck.k9.activity.compose.AttachmentPresenter.checkOkForSendingOrDraftSaving()",
        "kind": "method",
        "sourceText": "public boolean checkOkForSendingOrDraftSaving() {\r\n    if (actionToPerformAfterWaiting != com.fsck.k9.activity.compose.AttachmentPresenter.WaitingAction.NONE) {\r\n        return true;\r\n    }\r\n    if (hasLoadingAttachments()) {\r\n        actionToPerformAfterWaiting = com.fsck.k9.activity.compose.AttachmentPresenter.WaitingAction.SEND;\r\n        attachmentMvpView.showWaitingForAttachmentDialog(actionToPerformAfterWaiting);\r\n        return true;\r\n    }\r\n    return false;\r\n}",
        "name": "checkOkForSendingOrDraftSaving()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "loadNonInlineAttachments(com.fsck.k9.mailstore.MessageViewInfo)",
        "qualifiedName": "com.fsck.k9.activity.compose.AttachmentPresenter.loadNonInlineAttachments(com.fsck.k9.mailstore.MessageViewInfo)",
        "kind": "method",
        "sourceText": "public boolean loadNonInlineAttachments(com.fsck.k9.mailstore.MessageViewInfo messageViewInfo) {\r\n    boolean allPartsAvailable = true;\r\n    for (com.fsck.k9.mailstore.AttachmentViewInfo attachmentViewInfo : messageViewInfo.attachments) {\r\n        if (attachmentViewInfo.inlineAttachment) {\r\n            continue;\r\n        }\r\n        if (!attachmentViewInfo.isContentAvailable()) {\r\n            allPartsAvailable = false;\r\n            continue;\r\n        }\r\n        addAttachment(attachmentViewInfo);\r\n    }\r\n    return allPartsAvailable;\r\n}",
        "name": "loadNonInlineAttachments(com.fsck.k9.mailstore.MessageViewInfo)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.activity.compose.RecipientAdapter": [
      {
        "visibility": "public",
        "simpleName": "getView(int,android.view.View,android.view.ViewGroup)",
        "qualifiedName": "com.fsck.k9.activity.compose.RecipientAdapter.getView(int,android.view.View,android.view.ViewGroup)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic android.view.View getView(int position, android.view.View view, android.view.ViewGroup parent) {\r\n    if (view == null) {\r\n        view = newView(parent);\r\n    }\r\n    com.fsck.k9.view.RecipientSelectView.Recipient recipient = getItem(position);\r\n    bindView(view, recipient);\r\n    return view;\r\n}",
        "name": "getView(int,android.view.View,android.view.ViewGroup)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getFilter()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.activity.compose.RecipientAdapter.getFilter()",
        "sourceText": "@java.lang.Override\r\npublic android.widget.Filter getFilter() {\r\n    return new android.widget.Filter() {\r\n        @java.lang.Override\r\n        protected com.fsck.k9.activity.compose.FilterResults performFiltering(java.lang.CharSequence constraint) {\r\n            if (recipients == null) {\r\n                return null;\r\n            }\r\n            com.fsck.k9.activity.compose.FilterResults result = new com.fsck.k9.activity.compose.FilterResults();\r\n            result.values = recipients;\r\n            result.count = recipients.size();\r\n            return result;\r\n        }\r\n\r\n        @java.lang.Override\r\n        protected void publishResults(java.lang.CharSequence constraint, com.fsck.k9.activity.compose.FilterResults results) {\r\n            notifyDataSetChanged();\r\n        }\r\n    };\r\n}",
        "name": "getFilter()",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.activity.compose.PgpEnabledErrorDialog": [
      {
        "visibility": "public",
        "simpleName": "onCreateDialog(android.os.Bundle)",
        "qualifiedName": "com.fsck.k9.activity.compose.PgpEnabledErrorDialog.onCreateDialog(android.os.Bundle)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic android.app.Dialog onCreateDialog(android.os.Bundle savedInstanceState) {\r\n    android.app.Activity activity = getActivity();\r\n    boolean isGotItDialog = getArguments().getBoolean(com.fsck.k9.activity.compose.PgpEnabledErrorDialog.ARG_IS_GOTIT);\r\n    @android.annotation.SuppressLint(\"InflateParams\")\r\n    android.view.View view = android.view.LayoutInflater.from(activity).inflate(R.layout.openpgp_enabled_error_dialog, null);\r\n    android.app.AlertDialog.Builder builder = new android.app.AlertDialog.Builder(activity);\r\n    builder.setView(view);\r\n    builder.setNegativeButton(isGotItDialog ? R.string.openpgp_enabled_error_gotit : R.string.openpgp_enabled_error_back, new android.content.DialogInterface.OnClickListener() {\r\n        @java.lang.Override\r\n        public void onClick(android.content.DialogInterface dialog, int which) {\r\n            dialog.dismiss();\r\n        }\r\n    });\r\n    builder.setPositiveButton(R.string.openpgp_enabled_error_disable, new android.content.DialogInterface.OnClickListener() {\r\n        @java.lang.Override\r\n        public void onClick(android.content.DialogInterface dialog, int which) {\r\n            android.app.Activity activity = getActivity();\r\n            if (activity == null) {\r\n                return;\r\n            }\r\n            ((com.fsck.k9.activity.compose.PgpEnabledErrorDialog.OnOpenPgpDisableListener) (activity)).onOpenPgpClickDisable();\r\n            dialog.dismiss();\r\n        }\r\n    });\r\n    return builder.create();\r\n}",
        "name": "onCreateDialog(android.os.Bundle)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "newInstance(boolean,int)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.activity.compose.PgpEnabledErrorDialog.newInstance(boolean,int)",
        "sourceText": "public static com.fsck.k9.activity.compose.PgpEnabledErrorDialog newInstance(boolean isGotItDialog, @android.support.annotation.IdRes\r\nint showcaseView) {\r\n    com.fsck.k9.activity.compose.PgpEnabledErrorDialog dialog = new com.fsck.k9.activity.compose.PgpEnabledErrorDialog();\r\n    android.os.Bundle args = new android.os.Bundle();\r\n    args.putInt(com.fsck.k9.view.HighlightDialogFragment.ARG_HIGHLIGHT_VIEW, showcaseView);\r\n    args.putBoolean(com.fsck.k9.activity.compose.PgpEnabledErrorDialog.ARG_IS_GOTIT, isGotItDialog);\r\n    dialog.setArguments(args);\r\n    return dialog;\r\n}",
        "name": "newInstance(boolean,int)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.activity.loader": {
    "com.fsck.k9.activity.loader.AttachmentContentLoader": [
      {
        "visibility": "public",
        "simpleName": "loadInBackground()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.activity.loader.AttachmentContentLoader.loadInBackground()",
        "sourceText": "@java.lang.Override\r\npublic com.fsck.k9.activity.misc.Attachment loadInBackground() {\r\n    android.content.Context context = getContext();\r\n    try {\r\n        java.io.File file = java.io.File.createTempFile(com.fsck.k9.activity.loader.AttachmentContentLoader.FILENAME_PREFIX, null, context.getCacheDir());\r\n        file.deleteOnExit();\r\n        timber.log.Timber.v(\"Saving attachment to %s\", file.getAbsolutePath());\r\n        de.cketti.safecontentresolver.SafeContentResolver safeContentResolver = de.cketti.safecontentresolver.SafeContentResolverCompat.newInstance(context);\r\n        java.io.InputStream in = safeContentResolver.openInputStream(sourceAttachment.uri);\r\n        try {\r\n            java.io.FileOutputStream out = new java.io.FileOutputStream(file);\r\n            try {\r\n                org.apache.commons.io.IOUtils.copy(in, out);\r\n            } finally {\r\n                out.close();\r\n            }\r\n        } finally {\r\n            in.close();\r\n        }\r\n        cachedResultAttachment = sourceAttachment.deriveWithLoadComplete(file.getAbsolutePath());\r\n        return cachedResultAttachment;\r\n    } catch (java.io.IOException e) {\r\n        timber.log.Timber.e(e, \"Error saving attachment!\");\r\n    }\r\n    cachedResultAttachment = sourceAttachment.deriveWithLoadCancelled();\r\n    return cachedResultAttachment;\r\n}",
        "name": "loadInBackground()",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.activity.loader.AttachmentInfoLoader": [
      {
        "visibility": "public",
        "simpleName": "loadInBackground()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.activity.loader.AttachmentInfoLoader.loadInBackground()",
        "sourceText": "@java.lang.Override\r\npublic com.fsck.k9.activity.misc.Attachment loadInBackground() {\r\n    android.net.Uri uri = sourceAttachment.uri;\r\n    java.lang.String contentType = sourceAttachment.contentType;\r\n    long size = -1;\r\n    java.lang.String name = null;\r\n    android.content.ContentResolver contentResolver = getContext().getContentResolver();\r\n    android.database.Cursor metadataCursor = contentResolver.query(uri, new java.lang.String[]{ android.provider.OpenableColumns.DISPLAY_NAME, android.provider.OpenableColumns.SIZE }, null, null, null);\r\n    if (metadataCursor != null) {\r\n        try {\r\n            if (metadataCursor.moveToFirst()) {\r\n                name = metadataCursor.getString(0);\r\n                size = metadataCursor.getInt(1);\r\n            }\r\n        } finally {\r\n            metadataCursor.close();\r\n        }\r\n    }\r\n    if (name == null) {\r\n        name = uri.getLastPathSegment();\r\n    }\r\n    java.lang.String usableContentType = contentResolver.getType(uri);\r\n    if (((usableContentType == null) && (contentType != null)) && (contentType.indexOf('*') != (-1))) {\r\n        usableContentType = contentType;\r\n    }\r\n    if (usableContentType == null) {\r\n        usableContentType = com.fsck.k9.mail.internet.MimeUtility.getMimeTypeByExtension(name);\r\n    }\r\n    if (size <= 0) {\r\n        java.lang.String uriString = uri.toString();\r\n        if (uriString.startsWith(\"file://\")) {\r\n            java.io.File f = new java.io.File(uriString.substring(\"file://\".length()));\r\n            size = f.length();\r\n        } else {\r\n            timber.log.Timber.v(\"Not a file: %s\", uriString);\r\n        }\r\n    } else {\r\n        timber.log.Timber.v(\"old attachment.size: %d\", size);\r\n    }\r\n    timber.log.Timber.v(\"new attachment.size: %d\", size);\r\n    cachedResultAttachment = sourceAttachment.deriveWithMetadataLoaded(usableContentType, name, size);\r\n    return cachedResultAttachment;\r\n}",
        "name": "loadInBackground()",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.activity.misc": {
    "com.fsck.k9.activity.misc.ExtendedAsyncTask": [
      {
        "visibility": "public",
        "simpleName": "restore(android.app.Activity)",
        "qualifiedName": "com.fsck.k9.activity.misc.ExtendedAsyncTask.restore(android.app.Activity)",
        "kind": "method",
        "sourceText": "/**\r\n * Connect this {@link AsyncTask} to a new {@link Activity} instance after the activity\r\n * was restarted due to a configuration change.\r\n *\r\n * <p>\r\n * This also creates a new progress dialog that is bound to the new activity.\r\n * </p>\r\n *\r\n * @param activity\r\n * \t\tThe new {@code Activity} instance. Never {@code null}.\r\n */\r\n@java.lang.Override\r\npublic void restore(android.app.Activity activity) {\r\n    mActivity = activity;\r\n    showProgressDialog();\r\n}",
        "name": "restore(android.app.Activity)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "retain()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.activity.misc.ExtendedAsyncTask.retain()",
        "sourceText": "/**\r\n * Detach this {@link AsyncTask} from the {@link Activity} it was bound to.\r\n *\r\n * <p>\r\n * This needs to be called when the current activity is being destroyed during an activity\r\n * restart due to a configuration change.<br/>\r\n * We also have to destroy the progress dialog because it's bound to the activity that's\r\n * being destroyed.\r\n * </p>\r\n *\r\n * @return {@code true} if this instance should be retained; {@code false} otherwise.\r\n * @see Activity#onRetainNonConfigurationInstance()\r\n */\r\n@java.lang.Override\r\npublic boolean retain() {\r\n    boolean retain = false;\r\n    if (mProgressDialog != null) {\r\n        removeProgressDialog();\r\n        retain = true;\r\n    }\r\n    mActivity = null;\r\n    return retain;\r\n}",
        "name": "retain()",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.activity.misc.SwipeGestureDetector": [
      {
        "visibility": "public",
        "simpleName": "onFling(android.view.MotionEvent,android.view.MotionEvent,float,float)",
        "qualifiedName": "com.fsck.k9.activity.misc.SwipeGestureDetector.onFling(android.view.MotionEvent,android.view.MotionEvent,float,float)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic boolean onFling(android.view.MotionEvent e1, android.view.MotionEvent e2, float velocityX, float velocityY) {\r\n    // Apparently sometimes e1 is null\r\n    // Found a workaround here: http://stackoverflow.com/questions/4151385/\r\n    if (e1 == null) {\r\n        e1 = mLastOnDownEvent;\r\n    }\r\n    // Make sure we avoid NullPointerExceptions\r\n    if ((e1 == null) || (e2 == null)) {\r\n        return false;\r\n    }\r\n    // Calculate how much was actually swiped.\r\n    final float deltaX = e2.getX() - e1.getX();\r\n    final float deltaY = e2.getY() - e1.getY();\r\n    // Calculate the minimum distance required for this to be considered a swipe.\r\n    final int minDistance = ((int) (java.lang.Math.abs(deltaY * 4)));\r\n    try {\r\n        if ((java.lang.Math.abs(deltaY) > mMaxOffPath) || (java.lang.Math.abs(velocityX) < mMinVelocity)) {\r\n            return false;\r\n        }\r\n        if (deltaX < (minDistance * (-1))) {\r\n            mListener.onSwipeRightToLeft(e1, e2);\r\n        } else if (deltaX > minDistance) {\r\n            mListener.onSwipeLeftToRight(e1, e2);\r\n        } else {\r\n            return false;\r\n        }\r\n        // successful fling, cancel the 2nd event to prevent any other action from happening\r\n        // see http://code.google.com/p/android/issues/detail?id=8497\r\n        e2.setAction(MotionEvent.ACTION_CANCEL);\r\n    } catch (java.lang.Exception e) {\r\n        // nothing\r\n    }\r\n    return false;\r\n}",
        "name": "onFling(android.view.MotionEvent,android.view.MotionEvent,float,float)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.activity.misc.NonConfigurationInstance": [
      {
        "visibility": "public",
        "simpleName": "retain()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.activity.misc.NonConfigurationInstance.retain()",
        "sourceText": "/**\r\n * Decide whether to retain this {@code NonConfigurationInstance} and clean up resources if\r\n * necessary.\r\n *\r\n * <p>\r\n * This needs to be called when the current activity is being destroyed during an activity\r\n * restart due to a configuration change.<br>\r\n * Implementations should make sure that references to the {@code Activity} instance that is\r\n * about to be destroyed are cleared to avoid memory leaks. This includes all UI elements that\r\n * are bound to an activity (e.g. dialogs). They can be re-created in\r\n * {@link #restore(Activity)}.\r\n * </p>\r\n *\r\n * @return {@code true} if this instance should be retained; {@code false} otherwise.\r\n * @see Activity#onRetainNonConfigurationInstance()\r\n */\r\npublic boolean retain();",
        "name": "retain()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "restore(android.app.Activity)",
        "qualifiedName": "com.fsck.k9.activity.misc.NonConfigurationInstance.restore(android.app.Activity)",
        "kind": "method",
        "sourceText": "/**\r\n * Connect this retained {@code NonConfigurationInstance} to the new {@link Activity} instance\r\n * after the activity was restarted due to a configuration change.\r\n *\r\n * <p>\r\n * This also creates a new progress dialog that is bound to the new activity.\r\n * </p>\r\n *\r\n * @param activity\r\n * \t\tThe new {@code Activity} instance. Never {@code null}.\r\n */\r\npublic void restore(android.app.Activity activity);",
        "name": "restore(android.app.Activity)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.activity.setup": {
    "com.fsck.k9.activity.setup.ConnectionSecurityAdapter": [
      {
        "visibility": "public",
        "simpleName": "get(android.content.Context,com.fsck.k9.mail.ConnectionSecurity[])",
        "qualifiedName": "com.fsck.k9.activity.setup.ConnectionSecurityAdapter.get(android.content.Context,com.fsck.k9.mail.ConnectionSecurity[])",
        "kind": "method",
        "sourceText": "public static com.fsck.k9.activity.setup.ConnectionSecurityAdapter get(android.content.Context context, com.fsck.k9.mail.ConnectionSecurity[] items) {\r\n    com.fsck.k9.activity.setup.ConnectionSecurityHolder[] holders = new com.fsck.k9.activity.setup.ConnectionSecurityHolder[items.length];\r\n    for (int i = 0; i < items.length; i++) {\r\n        holders[i] = new com.fsck.k9.activity.setup.ConnectionSecurityHolder(items[i], context.getResources());\r\n    }\r\n    com.fsck.k9.activity.setup.ConnectionSecurityAdapter securityTypesAdapter = new com.fsck.k9.activity.setup.ConnectionSecurityAdapter(context, android.R.layout.simple_spinner_item, holders);\r\n    securityTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\r\n    return securityTypesAdapter;\r\n}",
        "name": "get(android.content.Context,com.fsck.k9.mail.ConnectionSecurity[])",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.activity.setup.OpenPgpAppSelectDialog": [
      {
        "visibility": "public",
        "simpleName": "onSelectProvider(java.lang.String)",
        "qualifiedName": "com.fsck.k9.activity.setup.OpenPgpAppSelectDialog.onSelectProvider(java.lang.String)",
        "kind": "method",
        "sourceText": "public void onSelectProvider(java.lang.String selectedPackage) {\r\n    if (com.fsck.k9.activity.setup.OpenPgpAppSelectDialog.APG_PROVIDER_PLACEHOLDER.equals(selectedPackage)) {\r\n        showApgDeprecationDialogFragment();\r\n        return;\r\n    }\r\n    persistOpenPgpProviderSetting(selectedPackage);\r\n    finish();\r\n}",
        "name": "onSelectProvider(java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onCreate(android.os.Bundle)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.activity.setup.OpenPgpAppSelectDialog.onCreate(android.os.Bundle)",
        "sourceText": "@java.lang.Override\r\npublic void onCreate(android.os.Bundle savedInstanceState) {\r\n    super.onCreate(savedInstanceState);\r\n    setTheme(com.fsck.k9.K9.getK9Theme() == com.fsck.k9.K9.Theme.LIGHT ? R.style.Theme_K9_Dialog_Translucent_Light : R.style.Theme_K9_Dialog_Translucent_Dark);\r\n    if (savedInstanceState == null) {\r\n        showOpenPgpSelectDialogFragment();\r\n    }\r\n}",
        "name": "onCreate(android.os.Bundle)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.activity.setup.SliderPreference": [
      {
        "visibility": "public",
        "simpleName": "getSummary()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.activity.setup.SliderPreference.getSummary()",
        "sourceText": "@java.lang.Override\r\npublic java.lang.CharSequence getSummary() {\r\n    if ((mSummaries != null) && (mSummaries.length > 0)) {\r\n        int index = ((int) (mValue * mSummaries.length));\r\n        index = java.lang.Math.min(index, mSummaries.length - 1);\r\n        return mSummaries[index];\r\n    } else {\r\n        return super.getSummary();\r\n    }\r\n}",
        "name": "getSummary()",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.autocrypt": {
    "com.fsck.k9.autocrypt.AutocryptHeaderParser": [],
    "com.fsck.k9.autocrypt.AutocryptOpenPgpApiInteractor": [
      {
        "visibility": "public",
        "simpleName": "getKeyMaterialFromApi(org.openintents.openpgp.util.OpenPgpApi,long,java.lang.String)",
        "qualifiedName": "com.fsck.k9.autocrypt.AutocryptOpenPgpApiInteractor.getKeyMaterialFromApi(org.openintents.openpgp.util.OpenPgpApi,long,java.lang.String)",
        "kind": "method",
        "sourceText": "public byte[] getKeyMaterialFromApi(org.openintents.openpgp.util.OpenPgpApi openPgpApi, long keyId, java.lang.String minimizeForUserId) {\r\n    android.content.Intent retreiveKeyIntent = new android.content.Intent(org.openintents.openpgp.util.OpenPgpApi.ACTION_GET_KEY);\r\n    retreiveKeyIntent.putExtra(OpenPgpApi.EXTRA_KEY_ID, keyId);\r\n    retreiveKeyIntent.putExtra(OpenPgpApi.EXTRA_MINIMIZE, true);\r\n    retreiveKeyIntent.putExtra(OpenPgpApi.EXTRA_MINIMIZE_USER_ID, minimizeForUserId);\r\n    java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();\r\n    android.content.Intent result = openPgpApi.executeApi(retreiveKeyIntent, ((java.io.InputStream) (null)), baos);\r\n    if (result.getIntExtra(OpenPgpApi.RESULT_CODE, OpenPgpApi.RESULT_CODE_ERROR) == org.openintents.openpgp.util.OpenPgpApi.RESULT_CODE_SUCCESS) {\r\n        return baos.toByteArray();\r\n    } else {\r\n        return null;\r\n    }\r\n}",
        "name": "getKeyMaterialFromApi(org.openintents.openpgp.util.OpenPgpApi,long,java.lang.String)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.autocrypt.AutocryptHeader": [
      {
        "visibility": "public",
        "simpleName": "equals(java.lang.Object)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.autocrypt.AutocryptHeader.equals(java.lang.Object)",
        "sourceText": "@java.lang.Override\r\npublic boolean equals(java.lang.Object o) {\r\n    if (this == o) {\r\n        return true;\r\n    }\r\n    if ((o == null) || (getClass() != o.getClass())) {\r\n        return false;\r\n    }\r\n    com.fsck.k9.autocrypt.AutocryptHeader that = ((com.fsck.k9.autocrypt.AutocryptHeader) (o));\r\n    if (isPreferEncryptMutual != that.isPreferEncryptMutual) {\r\n        return false;\r\n    }\r\n    if (!java.util.Arrays.equals(keyData, that.keyData)) {\r\n        return false;\r\n    }\r\n    if (!addr.equals(that.addr)) {\r\n        return false;\r\n    }\r\n    if (!parameters.equals(that.parameters)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}",
        "name": "equals(java.lang.Object)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.cache": {
    "com.fsck.k9.cache.EmailProviderCacheCursor": [
      {
        "visibility": "public",
        "simpleName": "moveToPosition(int)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.cache.EmailProviderCacheCursor.moveToPosition(int)",
        "sourceText": "@java.lang.Override\r\npublic boolean moveToPosition(int position) {\r\n    if (mHiddenRows.isEmpty()) {\r\n        return super.moveToPosition(position);\r\n    }\r\n    mPosition = position;\r\n    int newPosition = position;\r\n    for (int hiddenRow : mHiddenRows) {\r\n        if (hiddenRow > newPosition) {\r\n            break;\r\n        }\r\n        newPosition++;\r\n    }\r\n    return super.moveToPosition(newPosition);\r\n}",
        "name": "moveToPosition(int)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getInt(int)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.cache.EmailProviderCacheCursor.getInt(int)",
        "sourceText": "@java.lang.Override\r\npublic int getInt(int columnIndex) {\r\n    long messageId = getLong(mMessageIdColumn);\r\n    long threadRootId = getLong(mThreadRootColumn);\r\n    java.lang.String columnName = getColumnName(columnIndex);\r\n    java.lang.String value = mCache.getValueForMessage(messageId, columnName);\r\n    if (value != null) {\r\n        return java.lang.Integer.parseInt(value);\r\n    }\r\n    value = mCache.getValueForThread(threadRootId, columnName);\r\n    if (value != null) {\r\n        return java.lang.Integer.parseInt(value);\r\n    }\r\n    return super.getInt(columnIndex);\r\n}",
        "name": "getInt(int)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.cache.EmailProviderCache": [
      {
        "visibility": "public",
        "simpleName": "setValueForMessages(java.util.List,java.lang.String,java.lang.String)",
        "qualifiedName": "com.fsck.k9.cache.EmailProviderCache.setValueForMessages(java.util.List,java.lang.String,java.lang.String)",
        "kind": "method",
        "sourceText": "public void setValueForMessages(java.util.List<java.lang.Long> messageIds, java.lang.String columnName, java.lang.String value) {\r\n    synchronized(mMessageCache) {\r\n        for (java.lang.Long messageId : messageIds) {\r\n            java.util.Map<java.lang.String, java.lang.String> map = mMessageCache.get(messageId);\r\n            if (map == null) {\r\n                map = new java.util.HashMap<java.lang.String, java.lang.String>();\r\n                mMessageCache.put(messageId, map);\r\n            }\r\n            map.put(columnName, value);\r\n        }\r\n    }\r\n    notifyChange();\r\n}",
        "name": "setValueForMessages(java.util.List,java.lang.String,java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "setValueForThreads(java.util.List,java.lang.String,java.lang.String)",
        "qualifiedName": "com.fsck.k9.cache.EmailProviderCache.setValueForThreads(java.util.List,java.lang.String,java.lang.String)",
        "kind": "method",
        "sourceText": "public void setValueForThreads(java.util.List<java.lang.Long> threadRootIds, java.lang.String columnName, java.lang.String value) {\r\n    synchronized(mThreadCache) {\r\n        for (java.lang.Long threadRootId : threadRootIds) {\r\n            java.util.Map<java.lang.String, java.lang.String> map = mThreadCache.get(threadRootId);\r\n            if (map == null) {\r\n                map = new java.util.HashMap<java.lang.String, java.lang.String>();\r\n                mThreadCache.put(threadRootId, map);\r\n            }\r\n            map.put(columnName, value);\r\n        }\r\n    }\r\n    notifyChange();\r\n}",
        "name": "setValueForThreads(java.util.List,java.lang.String,java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "removeValueForThreads(java.util.List,java.lang.String)",
        "qualifiedName": "com.fsck.k9.cache.EmailProviderCache.removeValueForThreads(java.util.List,java.lang.String)",
        "kind": "method",
        "sourceText": "public void removeValueForThreads(java.util.List<java.lang.Long> threadRootIds, java.lang.String columnName) {\r\n    synchronized(mThreadCache) {\r\n        for (java.lang.Long threadRootId : threadRootIds) {\r\n            java.util.Map<java.lang.String, java.lang.String> map = mThreadCache.get(threadRootId);\r\n            if (map != null) {\r\n                map.remove(columnName);\r\n                if (map.isEmpty()) {\r\n                    mThreadCache.remove(threadRootId);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
        "name": "removeValueForThreads(java.util.List,java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getCache(java.lang.String,android.content.Context)",
        "qualifiedName": "com.fsck.k9.cache.EmailProviderCache.getCache(java.lang.String,android.content.Context)",
        "kind": "method",
        "sourceText": "public static synchronized com.fsck.k9.cache.EmailProviderCache getCache(java.lang.String accountUuid, android.content.Context context) {\r\n    if (com.fsck.k9.cache.EmailProviderCache.sContext == null) {\r\n        com.fsck.k9.cache.EmailProviderCache.sContext = context.getApplicationContext();\r\n    }\r\n    com.fsck.k9.cache.EmailProviderCache instance = com.fsck.k9.cache.EmailProviderCache.sInstances.get(accountUuid);\r\n    if (instance == null) {\r\n        instance = new com.fsck.k9.cache.EmailProviderCache(accountUuid);\r\n        com.fsck.k9.cache.EmailProviderCache.sInstances.put(accountUuid, instance);\r\n    }\r\n    return instance;\r\n}",
        "name": "getCache(java.lang.String,android.content.Context)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "hideMessages(java.util.List)",
        "qualifiedName": "com.fsck.k9.cache.EmailProviderCache.hideMessages(java.util.List)",
        "kind": "method",
        "sourceText": "public void hideMessages(java.util.List<com.fsck.k9.mailstore.LocalMessage> messages) {\r\n    synchronized(mHiddenMessageCache) {\r\n        for (com.fsck.k9.mailstore.LocalMessage message : messages) {\r\n            long messageId = message.getDatabaseId();\r\n            mHiddenMessageCache.put(messageId, message.getFolder().getDatabaseId());\r\n        }\r\n    }\r\n    notifyChange();\r\n}",
        "name": "hideMessages(java.util.List)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "unhideMessages(java.util.List)",
        "qualifiedName": "com.fsck.k9.cache.EmailProviderCache.unhideMessages(java.util.List)",
        "kind": "method",
        "sourceText": "public void unhideMessages(java.util.List<? extends com.fsck.k9.mail.Message> messages) {\r\n    synchronized(mHiddenMessageCache) {\r\n        for (com.fsck.k9.mail.Message message : messages) {\r\n            com.fsck.k9.mailstore.LocalMessage localMessage = ((com.fsck.k9.mailstore.LocalMessage) (message));\r\n            long messageId = localMessage.getDatabaseId();\r\n            long folderId = localMessage.getFolder().getDatabaseId();\r\n            java.lang.Long hiddenInFolder = mHiddenMessageCache.get(messageId);\r\n            if ((hiddenInFolder != null) && (hiddenInFolder == folderId)) {\r\n                mHiddenMessageCache.remove(messageId);\r\n            }\r\n        }\r\n    }\r\n}",
        "name": "unhideMessages(java.util.List)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "removeValueForMessages(java.util.List,java.lang.String)",
        "qualifiedName": "com.fsck.k9.cache.EmailProviderCache.removeValueForMessages(java.util.List,java.lang.String)",
        "kind": "method",
        "sourceText": "public void removeValueForMessages(java.util.List<java.lang.Long> messageIds, java.lang.String columnName) {\r\n    synchronized(mMessageCache) {\r\n        for (java.lang.Long messageId : messageIds) {\r\n            java.util.Map<java.lang.String, java.lang.String> map = mMessageCache.get(messageId);\r\n            if (map != null) {\r\n                map.remove(columnName);\r\n                if (map.isEmpty()) {\r\n                    mMessageCache.remove(messageId);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
        "name": "removeValueForMessages(java.util.List,java.lang.String)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.cache.TemporaryAttachmentStore": [
      {
        "visibility": "public",
        "simpleName": "getFileForWriting(android.content.Context,java.lang.String)",
        "qualifiedName": "com.fsck.k9.cache.TemporaryAttachmentStore.getFileForWriting(android.content.Context,java.lang.String)",
        "kind": "method",
        "sourceText": "public static java.io.File getFileForWriting(android.content.Context context, java.lang.String attachmentName) throws java.io.IOException {\r\n    java.io.File directory = com.fsck.k9.cache.TemporaryAttachmentStore.createOrCleanAttachmentDirectory(context);\r\n    java.lang.String filename = com.fsck.k9.helper.FileHelper.sanitizeFilename(attachmentName);\r\n    return new java.io.File(directory, filename);\r\n}",
        "name": "getFileForWriting(android.content.Context,java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getFile(android.content.Context,java.lang.String)",
        "qualifiedName": "com.fsck.k9.cache.TemporaryAttachmentStore.getFile(android.content.Context,java.lang.String)",
        "kind": "method",
        "sourceText": "public static java.io.File getFile(android.content.Context context, java.lang.String attachmentName) {\r\n    java.io.File directory = com.fsck.k9.cache.TemporaryAttachmentStore.getTemporaryAttachmentDirectory(context);\r\n    java.lang.String filename = com.fsck.k9.helper.FileHelper.sanitizeFilename(attachmentName);\r\n    return new java.io.File(directory, filename);\r\n}",
        "name": "getFile(android.content.Context,java.lang.String)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.controller": {
    "com.fsck.k9.controller.MessagingControllerPushReceiver": [
      {
        "visibility": "public",
        "simpleName": "getPushState(java.lang.String)",
        "qualifiedName": "com.fsck.k9.controller.MessagingControllerPushReceiver.getPushState(java.lang.String)",
        "kind": "method",
        "sourceText": "public java.lang.String getPushState(java.lang.String folderName) {\r\n    com.fsck.k9.mailstore.LocalFolder localFolder = null;\r\n    try {\r\n        com.fsck.k9.mailstore.LocalStore localStore = account.getLocalStore();\r\n        localFolder = localStore.getFolder(folderName);\r\n        localFolder.open(Folder.OPEN_MODE_RW);\r\n        return localFolder.getPushState();\r\n    } catch (java.lang.Exception e) {\r\n        timber.log.Timber.e(e, \"Unable to get push state from account %s, folder %s\", account.getDescription(), folderName);\r\n        return null;\r\n    } finally {\r\n        if (localFolder != null) {\r\n            localFolder.close();\r\n        }\r\n    }\r\n}",
        "name": "getPushState(java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "syncFolder(com.fsck.k9.mail.Folder)",
        "qualifiedName": "com.fsck.k9.controller.MessagingControllerPushReceiver.syncFolder(com.fsck.k9.mail.Folder)",
        "kind": "method",
        "sourceText": "public void syncFolder(com.fsck.k9.mail.Folder folder) {\r\n    timber.log.Timber.v(\"syncFolder(%s)\", folder.getName());\r\n    final java.util.concurrent.CountDownLatch latch = new java.util.concurrent.CountDownLatch(1);\r\n    controller.synchronizeMailbox(account, folder.getName(), new com.fsck.k9.controller.SimpleMessagingListener() {\r\n        @java.lang.Override\r\n        public void synchronizeMailboxFinished(com.fsck.k9.Account account, java.lang.String folder, int totalMessagesInMailbox, int numNewMessages) {\r\n            latch.countDown();\r\n        }\r\n\r\n        @java.lang.Override\r\n        public void synchronizeMailboxFailed(com.fsck.k9.Account account, java.lang.String folder, java.lang.String message) {\r\n            latch.countDown();\r\n        }\r\n    }, folder);\r\n    timber.log.Timber.v(\"syncFolder(%s) about to await latch release\", folder.getName());\r\n    try {\r\n        latch.await();\r\n        timber.log.Timber.v(\"syncFolder(%s) got latch release\", folder.getName());\r\n    } catch (java.lang.Exception e) {\r\n        timber.log.Timber.e(e, \"Interrupted while awaiting latch release\");\r\n    }\r\n}",
        "name": "syncFolder(com.fsck.k9.mail.Folder)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "pushError(java.lang.String,java.lang.Exception)",
        "qualifiedName": "com.fsck.k9.controller.MessagingControllerPushReceiver.pushError(java.lang.String,java.lang.Exception)",
        "kind": "method",
        "sourceText": "public void pushError(java.lang.String errorMessage, java.lang.Exception e) {\r\n    java.lang.String errMess = errorMessage;\r\n    controller.notifyUserIfCertificateProblem(account, e, true);\r\n    if ((errMess == null) && (e != null)) {\r\n        errMess = e.getMessage();\r\n    }\r\n    timber.log.Timber.e(e, errMess);\r\n}",
        "name": "pushError(java.lang.String,java.lang.Exception)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.controller.MemorizingMessagingListener": [
      {
        "visibility": "public",
        "simpleName": "pendingCommandsProcessing(com.fsck.k9.Account)",
        "qualifiedName": "com.fsck.k9.controller.MemorizingMessagingListener.pendingCommandsProcessing(com.fsck.k9.Account)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic synchronized void pendingCommandsProcessing(com.fsck.k9.Account account) {\r\n    com.fsck.k9.controller.MemorizingMessagingListener.Memory memory = getMemory(account, null);\r\n    memory.processingState = com.fsck.k9.controller.MemorizingMessagingListener.MemorizingState.STARTED;\r\n    memory.folderCompleted = 0;\r\n    memory.folderTotal = 0;\r\n}",
        "name": "pendingCommandsProcessing(com.fsck.k9.Account)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "synchronizeMailboxProgress(com.fsck.k9.Account,java.lang.String,int,int)",
        "qualifiedName": "com.fsck.k9.controller.MemorizingMessagingListener.synchronizeMailboxProgress(com.fsck.k9.Account,java.lang.String,int,int)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic synchronized void synchronizeMailboxProgress(com.fsck.k9.Account account, java.lang.String folderName, int completed, int total) {\r\n    com.fsck.k9.controller.MemorizingMessagingListener.Memory memory = getMemory(account, folderName);\r\n    memory.folderCompleted = completed;\r\n    memory.folderTotal = total;\r\n}",
        "name": "synchronizeMailboxProgress(com.fsck.k9.Account,java.lang.String,int,int)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "setPushActive(com.fsck.k9.Account,java.lang.String,boolean)",
        "qualifiedName": "com.fsck.k9.controller.MemorizingMessagingListener.setPushActive(com.fsck.k9.Account,java.lang.String,boolean)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic synchronized void setPushActive(com.fsck.k9.Account account, java.lang.String folderName, boolean active) {\r\n    com.fsck.k9.controller.MemorizingMessagingListener.Memory memory = getMemory(account, folderName);\r\n    memory.pushingState = (active) ? com.fsck.k9.controller.MemorizingMessagingListener.MemorizingState.STARTED : com.fsck.k9.controller.MemorizingMessagingListener.MemorizingState.FINISHED;\r\n}",
        "name": "setPushActive(com.fsck.k9.Account,java.lang.String,boolean)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "sendPendingMessagesStarted(com.fsck.k9.Account)",
        "qualifiedName": "com.fsck.k9.controller.MemorizingMessagingListener.sendPendingMessagesStarted(com.fsck.k9.Account)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic synchronized void sendPendingMessagesStarted(com.fsck.k9.Account account) {\r\n    com.fsck.k9.controller.MemorizingMessagingListener.Memory memory = getMemory(account, null);\r\n    memory.sendingState = com.fsck.k9.controller.MemorizingMessagingListener.MemorizingState.STARTED;\r\n    memory.folderCompleted = 0;\r\n    memory.folderTotal = 0;\r\n}",
        "name": "sendPendingMessagesStarted(com.fsck.k9.Account)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "synchronizeMailboxFailed(com.fsck.k9.Account,java.lang.String,java.lang.String)",
        "qualifiedName": "com.fsck.k9.controller.MemorizingMessagingListener.synchronizeMailboxFailed(com.fsck.k9.Account,java.lang.String,java.lang.String)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic synchronized void synchronizeMailboxFailed(com.fsck.k9.Account account, java.lang.String folder, java.lang.String message) {\r\n    com.fsck.k9.controller.MemorizingMessagingListener.Memory memory = getMemory(account, folder);\r\n    memory.syncingState = com.fsck.k9.controller.MemorizingMessagingListener.MemorizingState.FAILED;\r\n    memory.failureMessage = message;\r\n}",
        "name": "synchronizeMailboxFailed(com.fsck.k9.Account,java.lang.String,java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "pendingCommandsFinished(com.fsck.k9.Account)",
        "qualifiedName": "com.fsck.k9.controller.MemorizingMessagingListener.pendingCommandsFinished(com.fsck.k9.Account)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic synchronized void pendingCommandsFinished(com.fsck.k9.Account account) {\r\n    com.fsck.k9.controller.MemorizingMessagingListener.Memory memory = getMemory(account, null);\r\n    memory.processingState = com.fsck.k9.controller.MemorizingMessagingListener.MemorizingState.FINISHED;\r\n}",
        "name": "pendingCommandsFinished(com.fsck.k9.Account)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "synchronizeMailboxFinished(com.fsck.k9.Account,java.lang.String,int,int)",
        "qualifiedName": "com.fsck.k9.controller.MemorizingMessagingListener.synchronizeMailboxFinished(com.fsck.k9.Account,java.lang.String,int,int)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic synchronized void synchronizeMailboxFinished(com.fsck.k9.Account account, java.lang.String folder, int totalMessagesInMailbox, int numNewMessages) {\r\n    com.fsck.k9.controller.MemorizingMessagingListener.Memory memory = getMemory(account, folder);\r\n    memory.syncingState = com.fsck.k9.controller.MemorizingMessagingListener.MemorizingState.FINISHED;\r\n    memory.syncingTotalMessagesInMailbox = totalMessagesInMailbox;\r\n    memory.syncingNumNewMessages = numNewMessages;\r\n}",
        "name": "synchronizeMailboxFinished(com.fsck.k9.Account,java.lang.String,int,int)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "sendPendingMessagesCompleted(com.fsck.k9.Account)",
        "qualifiedName": "com.fsck.k9.controller.MemorizingMessagingListener.sendPendingMessagesCompleted(com.fsck.k9.Account)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic synchronized void sendPendingMessagesCompleted(com.fsck.k9.Account account) {\r\n    com.fsck.k9.controller.MemorizingMessagingListener.Memory memory = getMemory(account, null);\r\n    memory.sendingState = com.fsck.k9.controller.MemorizingMessagingListener.MemorizingState.FINISHED;\r\n}",
        "name": "sendPendingMessagesCompleted(com.fsck.k9.Account)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "synchronizeMailboxStarted(com.fsck.k9.Account,java.lang.String)",
        "qualifiedName": "com.fsck.k9.controller.MemorizingMessagingListener.synchronizeMailboxStarted(com.fsck.k9.Account,java.lang.String)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic synchronized void synchronizeMailboxStarted(com.fsck.k9.Account account, java.lang.String folder) {\r\n    com.fsck.k9.controller.MemorizingMessagingListener.Memory memory = getMemory(account, folder);\r\n    memory.syncingState = com.fsck.k9.controller.MemorizingMessagingListener.MemorizingState.STARTED;\r\n    memory.folderCompleted = 0;\r\n    memory.folderTotal = 0;\r\n}",
        "name": "synchronizeMailboxStarted(com.fsck.k9.Account,java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "sendPendingMessagesFailed(com.fsck.k9.Account)",
        "qualifiedName": "com.fsck.k9.controller.MemorizingMessagingListener.sendPendingMessagesFailed(com.fsck.k9.Account)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic synchronized void sendPendingMessagesFailed(com.fsck.k9.Account account) {\r\n    com.fsck.k9.controller.MemorizingMessagingListener.Memory memory = getMemory(account, null);\r\n    memory.sendingState = com.fsck.k9.controller.MemorizingMessagingListener.MemorizingState.FAILED;\r\n}",
        "name": "sendPendingMessagesFailed(com.fsck.k9.Account)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.controller.ProgressBodyFactory": []
  },
  "com.fsck.k9.crypto": {
    "com.fsck.k9.crypto.MessageCryptoStructureDetector": [
      {
        "visibility": "public",
        "simpleName": "isPartPgpInlineEncrypted(com.fsck.k9.mail.Part)",
        "qualifiedName": "com.fsck.k9.crypto.MessageCryptoStructureDetector.isPartPgpInlineEncrypted(com.fsck.k9.mail.Part)",
        "kind": "method",
        "sourceText": "public static boolean isPartPgpInlineEncrypted(@android.support.annotation.Nullable\r\ncom.fsck.k9.mail.Part part) {\r\n    if (part == null) {\r\n        return false;\r\n    }\r\n    if ((!part.isMimeType(com.fsck.k9.crypto.MessageCryptoStructureDetector.TEXT_PLAIN)) && (!part.isMimeType(com.fsck.k9.crypto.MessageCryptoStructureDetector.APPLICATION_PGP))) {\r\n        return false;\r\n    }\r\n    java.lang.String text = com.fsck.k9.mail.internet.MessageExtractor.getTextFromPart(part, com.fsck.k9.crypto.MessageCryptoStructureDetector.TEXT_LENGTH_FOR_INLINE_CHECK);\r\n    if (android.text.TextUtils.isEmpty(text)) {\r\n        return false;\r\n    }\r\n    text = text.trim();\r\n    return text.startsWith(com.fsck.k9.crypto.MessageCryptoStructureDetector.PGP_INLINE_START_MARKER);\r\n}",
        "name": "isPartPgpInlineEncrypted(com.fsck.k9.mail.Part)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "findMultipartEncryptedParts(com.fsck.k9.mail.Part)",
        "qualifiedName": "com.fsck.k9.crypto.MessageCryptoStructureDetector.findMultipartEncryptedParts(com.fsck.k9.mail.Part)",
        "kind": "method",
        "sourceText": "public static java.util.List<com.fsck.k9.mail.Part> findMultipartEncryptedParts(com.fsck.k9.mail.Part startPart) {\r\n    java.util.List<com.fsck.k9.mail.Part> encryptedParts = new java.util.ArrayList<>();\r\n    java.util.Stack<com.fsck.k9.mail.Part> partsToCheck = new java.util.Stack<>();\r\n    partsToCheck.push(startPart);\r\n    while (!partsToCheck.isEmpty()) {\r\n        com.fsck.k9.mail.Part part = partsToCheck.pop();\r\n        com.fsck.k9.mail.Body body = part.getBody();\r\n        if (com.fsck.k9.crypto.MessageCryptoStructureDetector.isPartMultipartEncrypted(part)) {\r\n            encryptedParts.add(part);\r\n            continue;\r\n        }\r\n        if (body instanceof com.fsck.k9.mail.Multipart) {\r\n            com.fsck.k9.mail.Multipart multipart = ((com.fsck.k9.mail.Multipart) (body));\r\n            for (int i = multipart.getCount() - 1; i >= 0; i--) {\r\n                com.fsck.k9.mail.BodyPart bodyPart = multipart.getBodyPart(i);\r\n                partsToCheck.push(bodyPart);\r\n            }\r\n        }\r\n    } \r\n    return encryptedParts;\r\n}",
        "name": "findMultipartEncryptedParts(com.fsck.k9.mail.Part)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "isMultipartEncryptedOpenPgpProtocol(com.fsck.k9.mail.Part)",
        "qualifiedName": "com.fsck.k9.crypto.MessageCryptoStructureDetector.isMultipartEncryptedOpenPgpProtocol(com.fsck.k9.mail.Part)",
        "kind": "method",
        "sourceText": "public static boolean isMultipartEncryptedOpenPgpProtocol(com.fsck.k9.mail.Part part) {\r\n    if (!com.fsck.k9.mail.internet.MimeUtility.isSameMimeType(part.getMimeType(), com.fsck.k9.crypto.MessageCryptoStructureDetector.MULTIPART_ENCRYPTED)) {\r\n        throw new java.lang.IllegalArgumentException(\"Part is not multipart/encrypted!\");\r\n    }\r\n    java.lang.String protocolParameter = com.fsck.k9.mail.internet.MimeUtility.getHeaderParameter(part.getContentType(), com.fsck.k9.crypto.MessageCryptoStructureDetector.PROTOCOL_PARAMETER);\r\n    return com.fsck.k9.crypto.MessageCryptoStructureDetector.APPLICATION_PGP_ENCRYPTED.equalsIgnoreCase(protocolParameter);\r\n}",
        "name": "isMultipartEncryptedOpenPgpProtocol(com.fsck.k9.mail.Part)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "isMultipartSignedOpenPgpProtocol(com.fsck.k9.mail.Part)",
        "qualifiedName": "com.fsck.k9.crypto.MessageCryptoStructureDetector.isMultipartSignedOpenPgpProtocol(com.fsck.k9.mail.Part)",
        "kind": "method",
        "sourceText": "public static boolean isMultipartSignedOpenPgpProtocol(com.fsck.k9.mail.Part part) {\r\n    if (!com.fsck.k9.mail.internet.MimeUtility.isSameMimeType(part.getMimeType(), com.fsck.k9.crypto.MessageCryptoStructureDetector.MULTIPART_SIGNED)) {\r\n        throw new java.lang.IllegalArgumentException(\"Part is not multipart/signed!\");\r\n    }\r\n    java.lang.String protocolParameter = com.fsck.k9.mail.internet.MimeUtility.getHeaderParameter(part.getContentType(), com.fsck.k9.crypto.MessageCryptoStructureDetector.PROTOCOL_PARAMETER);\r\n    return com.fsck.k9.crypto.MessageCryptoStructureDetector.APPLICATION_PGP_SIGNATURE.equalsIgnoreCase(protocolParameter);\r\n}",
        "name": "isMultipartSignedOpenPgpProtocol(com.fsck.k9.mail.Part)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "isPartMultipartEncrypted(com.fsck.k9.mail.Part)",
        "qualifiedName": "com.fsck.k9.crypto.MessageCryptoStructureDetector.isPartMultipartEncrypted(com.fsck.k9.mail.Part)",
        "kind": "method",
        "sourceText": "public static boolean isPartMultipartEncrypted(com.fsck.k9.mail.Part part) {\r\n    if (!com.fsck.k9.mail.internet.MimeUtility.isSameMimeType(part.getMimeType(), com.fsck.k9.crypto.MessageCryptoStructureDetector.MULTIPART_ENCRYPTED)) {\r\n        return false;\r\n    }\r\n    if (!(part.getBody() instanceof com.fsck.k9.mail.internet.MimeMultipart)) {\r\n        return false;\r\n    }\r\n    com.fsck.k9.mail.internet.MimeMultipart mimeMultipart = ((com.fsck.k9.mail.internet.MimeMultipart) (part.getBody()));\r\n    if (mimeMultipart.getCount() != 2) {\r\n        return false;\r\n    }\r\n    java.lang.String protocolParameter = com.fsck.k9.mail.internet.MimeUtility.getHeaderParameter(part.getContentType(), com.fsck.k9.crypto.MessageCryptoStructureDetector.PROTOCOL_PARAMETER);\r\n    // for partially downloaded messages the protocol parameter isn't yet available, so we'll just assume it's ok\r\n    boolean dataUnavailable = (protocolParameter == null) && (mimeMultipart.getBodyPart(1).getBody() == null);\r\n    boolean protocolMatches = com.fsck.k9.mail.internet.MimeUtility.isSameMimeType(protocolParameter, mimeMultipart.getBodyPart(0).getMimeType());\r\n    return dataUnavailable || protocolMatches;\r\n}",
        "name": "isPartMultipartEncrypted(com.fsck.k9.mail.Part)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "findPrimaryEncryptedOrSignedPart(com.fsck.k9.mail.Part,java.util.List)",
        "qualifiedName": "com.fsck.k9.crypto.MessageCryptoStructureDetector.findPrimaryEncryptedOrSignedPart(com.fsck.k9.mail.Part,java.util.List)",
        "kind": "method",
        "sourceText": "public static com.fsck.k9.mail.Part findPrimaryEncryptedOrSignedPart(com.fsck.k9.mail.Part part, java.util.List<com.fsck.k9.mail.Part> outputExtraParts) {\r\n    if (com.fsck.k9.crypto.MessageCryptoStructureDetector.isPartEncryptedOrSigned(part)) {\r\n        return part;\r\n    }\r\n    com.fsck.k9.mail.Part foundPart;\r\n    foundPart = com.fsck.k9.crypto.MessageCryptoStructureDetector.findPrimaryPartInAlternative(part);\r\n    if (foundPart != null) {\r\n        return foundPart;\r\n    }\r\n    foundPart = com.fsck.k9.crypto.MessageCryptoStructureDetector.findPrimaryPartInMixed(part, outputExtraParts);\r\n    if (foundPart != null) {\r\n        return foundPart;\r\n    }\r\n    return null;\r\n}",
        "name": "findPrimaryEncryptedOrSignedPart(com.fsck.k9.mail.Part,java.util.List)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getSignatureData(com.fsck.k9.mail.Part)",
        "qualifiedName": "com.fsck.k9.crypto.MessageCryptoStructureDetector.getSignatureData(com.fsck.k9.mail.Part)",
        "kind": "method",
        "sourceText": "public static byte[] getSignatureData(com.fsck.k9.mail.Part part) throws java.io.IOException, com.fsck.k9.mail.MessagingException {\r\n    if (com.fsck.k9.crypto.MessageCryptoStructureDetector.isPartMultipartSigned(part)) {\r\n        com.fsck.k9.mail.Body body = part.getBody();\r\n        if (body instanceof com.fsck.k9.mail.Multipart) {\r\n            com.fsck.k9.mail.Multipart multi = ((com.fsck.k9.mail.Multipart) (body));\r\n            com.fsck.k9.mail.BodyPart signatureBody = multi.getBodyPart(1);\r\n            java.io.ByteArrayOutputStream bos = new java.io.ByteArrayOutputStream();\r\n            signatureBody.getBody().writeTo(bos);\r\n            return bos.toByteArray();\r\n        }\r\n    }\r\n    return null;\r\n}",
        "name": "getSignatureData(com.fsck.k9.mail.Part)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "findMultipartSignedParts(com.fsck.k9.mail.Part,com.fsck.k9.ui.crypto.MessageCryptoAnnotations)",
        "qualifiedName": "com.fsck.k9.crypto.MessageCryptoStructureDetector.findMultipartSignedParts(com.fsck.k9.mail.Part,com.fsck.k9.ui.crypto.MessageCryptoAnnotations)",
        "kind": "method",
        "sourceText": "public static java.util.List<com.fsck.k9.mail.Part> findMultipartSignedParts(com.fsck.k9.mail.Part startPart, com.fsck.k9.ui.crypto.MessageCryptoAnnotations messageCryptoAnnotations) {\r\n    java.util.List<com.fsck.k9.mail.Part> signedParts = new java.util.ArrayList<>();\r\n    java.util.Stack<com.fsck.k9.mail.Part> partsToCheck = new java.util.Stack<>();\r\n    partsToCheck.push(startPart);\r\n    while (!partsToCheck.isEmpty()) {\r\n        com.fsck.k9.mail.Part part = partsToCheck.pop();\r\n        if (messageCryptoAnnotations.has(part)) {\r\n            com.fsck.k9.mailstore.CryptoResultAnnotation resultAnnotation = messageCryptoAnnotations.get(part);\r\n            com.fsck.k9.mail.internet.MimeBodyPart replacementData = resultAnnotation.getReplacementData();\r\n            if (replacementData != null) {\r\n                part = replacementData;\r\n            }\r\n        }\r\n        com.fsck.k9.mail.Body body = part.getBody();\r\n        if (com.fsck.k9.crypto.MessageCryptoStructureDetector.isPartMultipartSigned(part)) {\r\n            signedParts.add(part);\r\n            continue;\r\n        }\r\n        if (body instanceof com.fsck.k9.mail.Multipart) {\r\n            com.fsck.k9.mail.Multipart multipart = ((com.fsck.k9.mail.Multipart) (body));\r\n            for (int i = multipart.getCount() - 1; i >= 0; i--) {\r\n                com.fsck.k9.mail.BodyPart bodyPart = multipart.getBodyPart(i);\r\n                partsToCheck.push(bodyPart);\r\n            }\r\n        }\r\n    } \r\n    return signedParts;\r\n}",
        "name": "findMultipartSignedParts(com.fsck.k9.mail.Part,com.fsck.k9.ui.crypto.MessageCryptoAnnotations)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "findPgpInlineParts(com.fsck.k9.mail.Part)",
        "qualifiedName": "com.fsck.k9.crypto.MessageCryptoStructureDetector.findPgpInlineParts(com.fsck.k9.mail.Part)",
        "kind": "method",
        "sourceText": "public static java.util.List<com.fsck.k9.mail.Part> findPgpInlineParts(com.fsck.k9.mail.Part startPart) {\r\n    java.util.List<com.fsck.k9.mail.Part> inlineParts = new java.util.ArrayList<>();\r\n    java.util.Stack<com.fsck.k9.mail.Part> partsToCheck = new java.util.Stack<>();\r\n    partsToCheck.push(startPart);\r\n    while (!partsToCheck.isEmpty()) {\r\n        com.fsck.k9.mail.Part part = partsToCheck.pop();\r\n        com.fsck.k9.mail.Body body = part.getBody();\r\n        if (com.fsck.k9.crypto.MessageCryptoStructureDetector.isPartPgpInlineEncryptedOrSigned(part)) {\r\n            inlineParts.add(part);\r\n            continue;\r\n        }\r\n        if (body instanceof com.fsck.k9.mail.Multipart) {\r\n            com.fsck.k9.mail.Multipart multipart = ((com.fsck.k9.mail.Multipart) (body));\r\n            for (int i = multipart.getCount() - 1; i >= 0; i--) {\r\n                com.fsck.k9.mail.BodyPart bodyPart = multipart.getBodyPart(i);\r\n                partsToCheck.push(bodyPart);\r\n            }\r\n        }\r\n    } \r\n    return inlineParts;\r\n}",
        "name": "findPgpInlineParts(com.fsck.k9.mail.Part)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.crypto.OpenPgpApiHelper": [
      {
        "visibility": "public",
        "simpleName": "buildUserId(com.fsck.k9.Identity)",
        "qualifiedName": "com.fsck.k9.crypto.OpenPgpApiHelper.buildUserId(com.fsck.k9.Identity)",
        "kind": "method",
        "sourceText": "/**\r\n * Create an \"account name\" from the supplied identity for use with the OpenPgp API's\r\n * <code>EXTRA_ACCOUNT_NAME</code>.\r\n *\r\n * @return A string with the following format:\r\n<code>display name &lt;user@example.com&gt;</code>\r\n * @see org.openintents.openpgp.util.OpenPgpApi#EXTRA_ACCOUNT_NAME\r\n */\r\npublic static java.lang.String buildUserId(com.fsck.k9.Identity identity) {\r\n    java.lang.StringBuilder sb = new java.lang.StringBuilder();\r\n    java.lang.String name = identity.getName();\r\n    if (!android.text.TextUtils.isEmpty(name)) {\r\n        sb.append(name).append(\" \");\r\n    }\r\n    sb.append(\"<\").append(identity.getEmail()).append(\">\");\r\n    return sb.toString();\r\n}",
        "name": "buildUserId(com.fsck.k9.Identity)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.fragment": {
    "com.fsck.k9.fragment.ProgressDialogFragment": [
      {
        "visibility": "public",
        "simpleName": "newInstance(java.lang.String,java.lang.String)",
        "qualifiedName": "com.fsck.k9.fragment.ProgressDialogFragment.newInstance(java.lang.String,java.lang.String)",
        "kind": "method",
        "sourceText": "public static com.fsck.k9.fragment.ProgressDialogFragment newInstance(java.lang.String title, java.lang.String message) {\r\n    com.fsck.k9.fragment.ProgressDialogFragment fragment = new com.fsck.k9.fragment.ProgressDialogFragment();\r\n    android.os.Bundle args = new android.os.Bundle();\r\n    args.putString(com.fsck.k9.fragment.ProgressDialogFragment.ARG_TITLE, title);\r\n    args.putString(com.fsck.k9.fragment.ProgressDialogFragment.ARG_MESSAGE, message);\r\n    fragment.setArguments(args);\r\n    return fragment;\r\n}",
        "name": "newInstance(java.lang.String,java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onCancel(android.content.DialogInterface)",
        "qualifiedName": "com.fsck.k9.fragment.ProgressDialogFragment.onCancel(android.content.DialogInterface)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic void onCancel(android.content.DialogInterface dialog) {\r\n    android.app.Activity activity = getActivity();\r\n    if ((activity != null) && (activity instanceof com.fsck.k9.fragment.ProgressDialogFragment.CancelListener)) {\r\n        com.fsck.k9.fragment.ProgressDialogFragment.CancelListener listener = ((com.fsck.k9.fragment.ProgressDialogFragment.CancelListener) (activity));\r\n        listener.onProgressCancel(this);\r\n    }\r\n    super.onCancel(dialog);\r\n}",
        "name": "onCancel(android.content.DialogInterface)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onCreateDialog(android.os.Bundle)",
        "qualifiedName": "com.fsck.k9.fragment.ProgressDialogFragment.onCreateDialog(android.os.Bundle)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic android.app.Dialog onCreateDialog(android.os.Bundle savedInstanceState) {\r\n    android.os.Bundle args = getArguments();\r\n    java.lang.String title = args.getString(com.fsck.k9.fragment.ProgressDialogFragment.ARG_TITLE);\r\n    java.lang.String message = args.getString(com.fsck.k9.fragment.ProgressDialogFragment.ARG_MESSAGE);\r\n    android.app.ProgressDialog dialog = new android.app.ProgressDialog(getActivity());\r\n    dialog.setIndeterminate(true);\r\n    dialog.setTitle(title);\r\n    dialog.setMessage(message);\r\n    return dialog;\r\n}",
        "name": "onCreateDialog(android.os.Bundle)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.fragment.AttachmentDownloadDialogFragment": [
      {
        "visibility": "public",
        "simpleName": "onCancel(android.content.DialogInterface)",
        "qualifiedName": "com.fsck.k9.fragment.AttachmentDownloadDialogFragment.onCancel(android.content.DialogInterface)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic void onCancel(android.content.DialogInterface dialog) {\r\n    android.app.Activity activity = getActivity();\r\n    if ((activity != null) && (activity instanceof com.fsck.k9.fragment.AttachmentDownloadDialogFragment.AttachmentDownloadCancelListener)) {\r\n        com.fsck.k9.fragment.AttachmentDownloadDialogFragment.AttachmentDownloadCancelListener listener = ((com.fsck.k9.fragment.AttachmentDownloadDialogFragment.AttachmentDownloadCancelListener) (activity));\r\n        listener.onProgressCancel(this);\r\n    }\r\n    super.onCancel(dialog);\r\n}",
        "name": "onCancel(android.content.DialogInterface)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "newInstance(int,java.lang.String)",
        "qualifiedName": "com.fsck.k9.fragment.AttachmentDownloadDialogFragment.newInstance(int,java.lang.String)",
        "kind": "method",
        "sourceText": "public static com.fsck.k9.fragment.AttachmentDownloadDialogFragment newInstance(int size, java.lang.String message) {\r\n    com.fsck.k9.fragment.AttachmentDownloadDialogFragment fragment = new com.fsck.k9.fragment.AttachmentDownloadDialogFragment();\r\n    android.os.Bundle args = new android.os.Bundle();\r\n    args.putInt(com.fsck.k9.fragment.AttachmentDownloadDialogFragment.ARG_SIZE, size);\r\n    args.putString(com.fsck.k9.fragment.AttachmentDownloadDialogFragment.ARG_MESSAGE, message);\r\n    fragment.setArguments(args);\r\n    return fragment;\r\n}",
        "name": "newInstance(int,java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onCreateDialog(android.os.Bundle)",
        "qualifiedName": "com.fsck.k9.fragment.AttachmentDownloadDialogFragment.onCreateDialog(android.os.Bundle)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic android.app.Dialog onCreateDialog(android.os.Bundle savedInstanceState) {\r\n    android.os.Bundle args = getArguments();\r\n    int size = args.getInt(com.fsck.k9.fragment.AttachmentDownloadDialogFragment.ARG_SIZE);\r\n    java.lang.String message = args.getString(com.fsck.k9.fragment.AttachmentDownloadDialogFragment.ARG_MESSAGE);\r\n    messagingListener = new com.fsck.k9.controller.SimpleMessagingListener() {\r\n        @java.lang.Override\r\n        public void updateProgress(int progress) {\r\n            dialog.setProgress(progress);\r\n        }\r\n    };\r\n    messagingController = com.fsck.k9.controller.MessagingController.getInstance(getActivity());\r\n    messagingController.addListener(messagingListener);\r\n    dialog = new android.app.ProgressDialog(getActivity());\r\n    dialog.setMessage(message);\r\n    dialog.setMax(size);\r\n    dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\r\n    dialog.setProgress(0);\r\n    dialog.show();\r\n    return dialog;\r\n}",
        "name": "onCreateDialog(android.os.Bundle)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.fragment.MLFProjectionInfo": []
  },
  "com.fsck.k9.helper": {
    "com.fsck.k9.helper.Preconditions": [],
    "com.fsck.k9.helper.MergeCursorWithUniqueId": [
      {
        "visibility": "public",
        "simpleName": "getLong(int)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.helper.MergeCursorWithUniqueId.getLong(int)",
        "sourceText": "@java.lang.Override\r\npublic long getLong(int columnIndex) {\r\n    if (columnIndex == getUniqueIdColumnIndex()) {\r\n        long id = getPerCursorId();\r\n        if (id > com.fsck.k9.helper.MergeCursorWithUniqueId.MAX_ID) {\r\n            throw new java.lang.RuntimeException((((\"Sorry, \" + this.getClass().getName()) + \" can only handle '_id' values up to \") + com.fsck.k9.helper.MergeCursorWithUniqueId.SHIFT) + \" bits.\");\r\n        }\r\n        return (((long) (mActiveCursorIndex)) << com.fsck.k9.helper.MergeCursorWithUniqueId.SHIFT) + id;\r\n    }\r\n    return super.getLong(columnIndex);\r\n}",
        "name": "getLong(int)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.helper.ContactPicture": [
      {
        "visibility": "public",
        "simpleName": "getContactPictureLoader(android.content.Context)",
        "qualifiedName": "com.fsck.k9.helper.ContactPicture.getContactPictureLoader(android.content.Context)",
        "kind": "method",
        "sourceText": "public static com.fsck.k9.activity.misc.ContactPictureLoader getContactPictureLoader(android.content.Context context) {\r\n    final int defaultBgColor;\r\n    if (!com.fsck.k9.K9.isColorizeMissingContactPictures()) {\r\n        android.util.TypedValue outValue = new android.util.TypedValue();\r\n        context.getTheme().resolveAttribute(R.attr.contactPictureFallbackDefaultBackgroundColor, outValue, true);\r\n        defaultBgColor = outValue.data;\r\n    } else {\r\n        defaultBgColor = 0;\r\n    }\r\n    return new com.fsck.k9.activity.misc.ContactPictureLoader(context, defaultBgColor);\r\n}",
        "name": "getContactPictureLoader(android.content.Context)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.helper.jsoup": {
    "com.fsck.k9.helper.jsoup.NodeFilter": [
      {
        "visibility": "public",
        "simpleName": "tail(org.jsoup.nodes.Node,int)",
        "qualifiedName": "com.fsck.k9.helper.jsoup.NodeFilter.tail(org.jsoup.nodes.Node,int)",
        "kind": "method",
        "sourceText": "/**\r\n * Callback for when a node is last visited, after all of its descendants have been visited.\r\n *\r\n * @param node\r\n * \t\tthe node being visited.\r\n * @param depth\r\n * \t\tthe depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node\r\n * \t\tof that will have depth 1.\r\n * @return Filter decision\r\n */\r\n@android.support.annotation.NonNull\r\ncom.fsck.k9.helper.jsoup.NodeFilter.TailFilterDecision tail(org.jsoup.nodes.Node node, int depth);",
        "name": "tail(org.jsoup.nodes.Node,int)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "head(org.jsoup.nodes.Node,int)",
        "qualifiedName": "com.fsck.k9.helper.jsoup.NodeFilter.head(org.jsoup.nodes.Node,int)",
        "kind": "method",
        "sourceText": "/**\r\n * Callback for when a node is first visited.\r\n *\r\n * @param node\r\n * \t\tthe node being visited.\r\n * @param depth\r\n * \t\tthe depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node\r\n * \t\tof that will have depth 1.\r\n * @return Filter decision\r\n */\r\n@android.support.annotation.NonNull\r\ncom.fsck.k9.helper.jsoup.NodeFilter.HeadFilterDecision head(org.jsoup.nodes.Node node, int depth);",
        "name": "head(org.jsoup.nodes.Node,int)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.helper.jsoup.AdvancedNodeTraversor": []
  },
  "com.fsck.k9.mailstore": {
    "com.fsck.k9.mailstore.StoreSchemaDefinition": [
      {
        "visibility": "public",
        "simpleName": "doDbUpgrade(android.database.sqlite.SQLiteDatabase)",
        "qualifiedName": "com.fsck.k9.mailstore.StoreSchemaDefinition.doDbUpgrade(android.database.sqlite.SQLiteDatabase)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic void doDbUpgrade(final android.database.sqlite.SQLiteDatabase db) {\r\n    try {\r\n        upgradeDatabase(db);\r\n    } catch (java.lang.Exception e) {\r\n        if (com.fsck.k9.BuildConfig.DEBUG) {\r\n            throw new java.lang.Error(\"Exception while upgrading database\", e);\r\n        }\r\n        timber.log.Timber.e(e, \"Exception while upgrading database. Resetting the DB to v0\");\r\n        db.setVersion(0);\r\n        upgradeDatabase(db);\r\n    }\r\n}",
        "name": "doDbUpgrade(android.database.sqlite.SQLiteDatabase)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.mailstore.LocalStore": [
      {
        "visibility": "public",
        "simpleName": "getSize()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.mailstore.LocalStore.getSize()",
        "sourceText": "public long getSize() throws com.fsck.k9.mail.MessagingException {\r\n    final com.fsck.k9.mailstore.StorageManager storageManager = com.fsck.k9.mailstore.StorageManager.getInstance(context);\r\n    final java.io.File attachmentDirectory = storageManager.getAttachmentDirectory(account.getUuid(), database.getStorageProviderId());\r\n    return database.execute(false, new com.fsck.k9.mailstore.LockableDatabase.DbCallback<java.lang.Long>() {\r\n        @java.lang.Override\r\n        public java.lang.Long doDbWork(final android.database.sqlite.SQLiteDatabase db) {\r\n            final java.io.File[] files = attachmentDirectory.listFiles();\r\n            long attachmentLength = 0;\r\n            if (files != null) {\r\n                for (java.io.File file : files) {\r\n                    if (file.exists()) {\r\n                        attachmentLength += file.length();\r\n                    }\r\n                }\r\n            }\r\n            final java.io.File dbFile = storageManager.getDatabase(account.getUuid(), database.getStorageProviderId());\r\n            return dbFile.length() + attachmentLength;\r\n        }\r\n    });\r\n}",
        "name": "getSize()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getPendingCommands()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.mailstore.LocalStore.getPendingCommands()",
        "sourceText": "public java.util.List<com.fsck.k9.controller.MessagingControllerCommands.PendingCommand> getPendingCommands() throws com.fsck.k9.mail.MessagingException {\r\n    return database.execute(false, new com.fsck.k9.mailstore.LockableDatabase.DbCallback<java.util.List<com.fsck.k9.controller.MessagingControllerCommands.PendingCommand>>() {\r\n        @java.lang.Override\r\n        public java.util.List<com.fsck.k9.controller.MessagingControllerCommands.PendingCommand> doDbWork(final android.database.sqlite.SQLiteDatabase db) throws com.fsck.k9.mailstore.LockableDatabase.WrappedException {\r\n            android.database.Cursor cursor = null;\r\n            try {\r\n                cursor = db.query(\"pending_commands\", new java.lang.String[]{ \"id\", \"command\", \"data\" }, null, null, null, null, \"id ASC\");\r\n                java.util.List<com.fsck.k9.controller.MessagingControllerCommands.PendingCommand> commands = new java.util.ArrayList<>();\r\n                while (cursor.moveToNext()) {\r\n                    long databaseId = cursor.getLong(0);\r\n                    java.lang.String commandName = cursor.getString(1);\r\n                    java.lang.String data = cursor.getString(2);\r\n                    com.fsck.k9.controller.MessagingControllerCommands.PendingCommand command = pendingCommandSerializer.unserialize(databaseId, commandName, data);\r\n                    commands.add(command);\r\n                } \r\n                return commands;\r\n            } finally {\r\n                com.fsck.k9.helper.Utility.closeQuietly(cursor);\r\n            }\r\n        }\r\n    });\r\n}",
        "name": "getPendingCommands()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "createFolders(java.util.List,int)",
        "qualifiedName": "com.fsck.k9.mailstore.LocalStore.createFolders(java.util.List,int)",
        "kind": "method",
        "sourceText": "public void createFolders(final java.util.List<com.fsck.k9.mailstore.LocalFolder> foldersToCreate, final int visibleLimit) throws com.fsck.k9.mail.MessagingException {\r\n    database.execute(true, new com.fsck.k9.mailstore.LockableDatabase.DbCallback<java.lang.Void>() {\r\n        @java.lang.Override\r\n        public java.lang.Void doDbWork(final android.database.sqlite.SQLiteDatabase db) throws com.fsck.k9.mailstore.LockableDatabase.WrappedException {\r\n            for (com.fsck.k9.mailstore.LocalFolder folder : foldersToCreate) {\r\n                java.lang.String name = folder.getName();\r\n                final com.fsck.k9.mailstore.LocalFolder.PreferencesHolder prefHolder = folder.new PreferencesHolder();\r\n                // When created, special folders should always be displayed\r\n                // inbox should be integrated\r\n                // and the inbox and drafts folders should be syncced by default\r\n                if (account.isSpecialFolder(name)) {\r\n                    prefHolder.inTopGroup = true;\r\n                    prefHolder.displayClass = com.fsck.k9.mailstore.LocalFolder.FolderClass;\r\n                    if (name.equalsIgnoreCase(account.getInboxFolderName())) {\r\n                        prefHolder.integrate = true;\r\n                        prefHolder.notifyClass = com.fsck.k9.mailstore.LocalFolder.FolderClass;\r\n                        prefHolder.pushClass = com.fsck.k9.mailstore.LocalFolder.FolderClass;\r\n                    } else {\r\n                        prefHolder.pushClass = com.fsck.k9.mailstore.LocalFolder.FolderClass;\r\n                    }\r\n                    if (name.equalsIgnoreCase(account.getInboxFolderName()) || name.equalsIgnoreCase(account.getDraftsFolderName())) {\r\n                        prefHolder.syncClass = com.fsck.k9.mailstore.LocalFolder.FolderClass;\r\n                    } else {\r\n                        prefHolder.syncClass = com.fsck.k9.mailstore.LocalFolder.FolderClass;\r\n                    }\r\n                }\r\n                folder.refresh(name, prefHolder);// Recover settings from Preferences\r\n\r\n                db.execSQL(\"INSERT INTO folders (name, visible_limit, top_group, display_class, poll_class, notify_class, push_class, integrate) VALUES (?, ?, ?, ?, ?, ?, ?, ?)\", new java.lang.Object[]{ name, visibleLimit, prefHolder.inTopGroup ? 1 : 0, prefHolder.displayClass.name(), prefHolder.syncClass.name(), prefHolder.notifyClass.name(), prefHolder.pushClass.name(), prefHolder.integrate ? 1 : 0 });\r\n            }\r\n            return null;\r\n        }\r\n    });\r\n}",
        "name": "createFolders(java.util.List,int)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "clear()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.mailstore.LocalStore.clear()",
        "sourceText": "public void clear() throws com.fsck.k9.mail.MessagingException {\r\n    if (com.fsck.k9.K9.isDebug()) {\r\n        timber.log.Timber.i(\"Before prune size = %d\", getSize());\r\n    }\r\n    deleteAllMessageDataFromDisk();\r\n    if (com.fsck.k9.K9.isDebug()) {\r\n        timber.log.Timber.i(\"After prune / before compaction size = %d\", getSize());\r\n        timber.log.Timber.i(\"Before clear folder count = %d\", getFolderCount());\r\n        timber.log.Timber.i(\"Before clear message count = %d\", getMessageCount());\r\n        timber.log.Timber.i(\"After prune / before clear size = %d\", getSize());\r\n    }\r\n    database.execute(false, new com.fsck.k9.mailstore.LockableDatabase.DbCallback<java.lang.Void>() {\r\n        @java.lang.Override\r\n        public java.lang.Void doDbWork(final android.database.sqlite.SQLiteDatabase db) {\r\n            // We don't care about threads of deleted messages, so delete the whole table.\r\n            db.delete(\"threads\", null, null);\r\n            // Don't delete deleted messages. They are essentially placeholders for UIDs of messages that have\r\n            // been deleted locally.\r\n            db.delete(\"messages\", \"deleted = 0\", null);\r\n            // We don't need the search data now either\r\n            db.delete(\"messages_fulltext\", null, null);\r\n            return null;\r\n        }\r\n    });\r\n    compact();\r\n    if (com.fsck.k9.K9.isDebug()) {\r\n        timber.log.Timber.i(\"After clear message count = %d\", getMessageCount());\r\n        timber.log.Timber.i(\"After clear size = %d\", getSize());\r\n    }\r\n}",
        "name": "clear()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "removePendingCommands()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.mailstore.LocalStore.removePendingCommands()",
        "sourceText": "public void removePendingCommands() throws com.fsck.k9.mail.MessagingException {\r\n    database.execute(false, new com.fsck.k9.mailstore.LockableDatabase.DbCallback<java.lang.Void>() {\r\n        @java.lang.Override\r\n        public java.lang.Void doDbWork(final android.database.sqlite.SQLiteDatabase db) throws com.fsck.k9.mailstore.LockableDatabase.WrappedException {\r\n            db.delete(\"pending_commands\", null, null);\r\n            return null;\r\n        }\r\n    });\r\n}",
        "name": "removePendingCommands()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "setFlagForThreads(java.util.List,com.fsck.k9.mail.Flag,boolean)",
        "qualifiedName": "com.fsck.k9.mailstore.LocalStore.setFlagForThreads(java.util.List,com.fsck.k9.mail.Flag,boolean)",
        "kind": "method",
        "sourceText": "/**\r\n * Change the state of a flag for a list of threads.\r\n *\r\n * <p>\r\n * The goal of this method is to be fast. Currently this means using as few SQL UPDATE\r\n * statements as possible.\r\n *\r\n * @param threadRootIds\r\n * \t\tA list of root thread IDs.\r\n * @param flag\r\n * \t\tThe flag to change. This must be a flag with a separate column in the database.\r\n * @param newState\r\n * \t\t{@code true}, if the flag should be set. {@code false}, otherwise.\r\n */\r\npublic void setFlagForThreads(final java.util.List<java.lang.Long> threadRootIds, com.fsck.k9.mail.Flag flag, final boolean newState) throws com.fsck.k9.mail.MessagingException {\r\n    final java.lang.String flagColumn = com.fsck.k9.mailstore.LocalStore.getColumnNameForFlag(flag);\r\n    doBatchSetSelection(new com.fsck.k9.mailstore.LocalStore.BatchSetSelection() {\r\n        @java.lang.Override\r\n        public int getListSize() {\r\n            return threadRootIds.size();\r\n        }\r\n\r\n        @java.lang.Override\r\n        public java.lang.String getListItem(int index) {\r\n            return java.lang.Long.toString(threadRootIds.get(index));\r\n        }\r\n\r\n        @java.lang.Override\r\n        public void doDbWork(android.database.sqlite.SQLiteDatabase db, java.lang.String selectionSet, java.lang.String[] selectionArgs) throws com.fsck.k9.mailstore.UnavailableStorageException {\r\n            db.execSQL((((((((((\"UPDATE messages SET \" + flagColumn) + \" = \") + (newState ? \"1\" : \"0\")) + \" WHERE id IN (\") + \"SELECT m.id FROM threads t \") + \"LEFT JOIN messages m ON (t.message_id = m.id) \") + \"WHERE m.empty = 0 AND m.deleted = 0 \") + \"AND t.root\") + selectionSet) + \")\", selectionArgs);\r\n        }\r\n\r\n        @java.lang.Override\r\n        public void postDbWork() {\r\n            notifyChange();\r\n        }\r\n    }, com.fsck.k9.mailstore.LocalStore.THREAD_FLAG_UPDATE_BATCH_SIZE);\r\n}",
        "name": "setFlagForThreads(java.util.List,com.fsck.k9.mail.Flag,boolean)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "searchForMessages(com.fsck.k9.mail.MessageRetrievalListener,com.fsck.k9.search.LocalSearch)",
        "qualifiedName": "com.fsck.k9.mailstore.LocalStore.searchForMessages(com.fsck.k9.mail.MessageRetrievalListener,com.fsck.k9.search.LocalSearch)",
        "kind": "method",
        "sourceText": "public java.util.List<com.fsck.k9.mailstore.LocalMessage> searchForMessages(com.fsck.k9.mail.MessageRetrievalListener<com.fsck.k9.mailstore.LocalMessage> retrievalListener, com.fsck.k9.search.LocalSearch search) throws com.fsck.k9.mail.MessagingException {\r\n    java.lang.StringBuilder query = new java.lang.StringBuilder();\r\n    java.util.List<java.lang.String> queryArgs = new java.util.ArrayList<>();\r\n    com.fsck.k9.search.SqlQueryBuilder.buildWhereClause(account, search.getConditions(), query, queryArgs);\r\n    // Avoid \"ambiguous column name\" error by prefixing \"id\" with the message table name\r\n    java.lang.String where = com.fsck.k9.search.SqlQueryBuilder.addPrefixToSelection(new java.lang.String[]{ \"id\" }, \"messages.\", query.toString());\r\n    java.lang.String[] selectionArgs = queryArgs.toArray(new java.lang.String[queryArgs.size()]);\r\n    java.lang.String sqlQuery = (((((((\"SELECT \" + com.fsck.k9.mailstore.LocalStore.GET_MESSAGES_COLS) + \"FROM messages \") + \"LEFT JOIN threads ON (threads.message_id = messages.id) \") + \"LEFT JOIN message_parts ON (message_parts.id = messages.message_part_id) \") + \"LEFT JOIN folders ON (folders.id = messages.folder_id) WHERE \") + \"(empty = 0 AND deleted = 0)\") + (!android.text.TextUtils.isEmpty(where) ? (\" AND (\" + where) + \")\" : \"\")) + \" ORDER BY date DESC\";\r\n    timber.log.Timber.d(\"Query = %s\", sqlQuery);\r\n    return getMessages(retrievalListener, null, sqlQuery, selectionArgs);\r\n}",
        "name": "searchForMessages(com.fsck.k9.mail.MessageRetrievalListener,com.fsck.k9.search.LocalSearch)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getInstance(com.fsck.k9.Account,android.content.Context)",
        "qualifiedName": "com.fsck.k9.mailstore.LocalStore.getInstance(com.fsck.k9.Account,android.content.Context)",
        "kind": "method",
        "sourceText": "/**\r\n * Get an instance of a local mail store.\r\n *\r\n * @throws UnavailableStorageException\r\n * \t\tif not {@link StorageProvider#isReady(Context)}\r\n */\r\npublic static com.fsck.k9.mailstore.LocalStore getInstance(com.fsck.k9.Account account, android.content.Context context) throws com.fsck.k9.mail.MessagingException {\r\n    java.lang.String accountUuid = account.getUuid();\r\n    // Create new per-account lock object if necessary\r\n    com.fsck.k9.mailstore.LocalStore.sAccountLocks.putIfAbsent(accountUuid, new java.lang.Object());\r\n    // Use per-account locks so DatabaseUpgradeService always knows which account database is\r\n    // currently upgraded.\r\n    synchronized(com.fsck.k9.mailstore.LocalStore.sAccountLocks.get(accountUuid)) {\r\n        com.fsck.k9.mailstore.LocalStore store = com.fsck.k9.mailstore.LocalStore.sLocalStores.get(accountUuid);\r\n        if (store == null) {\r\n            // Creating a LocalStore instance will create or upgrade the database if\r\n            // necessary. This could take some time.\r\n            store = new com.fsck.k9.mailstore.LocalStore(account, context);\r\n            com.fsck.k9.mailstore.LocalStore.sLocalStores.put(accountUuid, store);\r\n        }\r\n        return store;\r\n    }\r\n}",
        "name": "getInstance(com.fsck.k9.Account,android.content.Context)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getAttachmentInfo(java.lang.String)",
        "qualifiedName": "com.fsck.k9.mailstore.LocalStore.getAttachmentInfo(java.lang.String)",
        "kind": "method",
        "sourceText": "public com.fsck.k9.mailstore.LocalStore.AttachmentInfo getAttachmentInfo(final java.lang.String attachmentId) throws com.fsck.k9.mail.MessagingException {\r\n    return database.execute(false, new com.fsck.k9.mailstore.LockableDatabase.DbCallback<com.fsck.k9.mailstore.LocalStore.AttachmentInfo>() {\r\n        @java.lang.Override\r\n        public com.fsck.k9.mailstore.LocalStore.AttachmentInfo doDbWork(final android.database.sqlite.SQLiteDatabase db) throws com.fsck.k9.mailstore.LockableDatabase.WrappedException {\r\n            android.database.Cursor cursor = db.query(\"message_parts\", new java.lang.String[]{ \"display_name\", \"decoded_body_size\", \"mime_type\" }, \"id = ?\", new java.lang.String[]{ attachmentId }, null, null, null);\r\n            try {\r\n                if (!cursor.moveToFirst()) {\r\n                    return null;\r\n                }\r\n                java.lang.String name = cursor.getString(0);\r\n                long size = cursor.getLong(1);\r\n                java.lang.String mimeType = cursor.getString(2);\r\n                final com.fsck.k9.mailstore.LocalStore.AttachmentInfo attachmentInfo = new com.fsck.k9.mailstore.LocalStore.AttachmentInfo();\r\n                attachmentInfo.name = name;\r\n                attachmentInfo.size = size;\r\n                attachmentInfo.type = mimeType;\r\n                return attachmentInfo;\r\n            } finally {\r\n                cursor.close();\r\n            }\r\n        }\r\n    });\r\n}",
        "name": "getAttachmentInfo(java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getMessagesInThread(long)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.mailstore.LocalStore.getMessagesInThread(long)",
        "sourceText": "public java.util.List<com.fsck.k9.mailstore.LocalMessage> getMessagesInThread(final long rootId) throws com.fsck.k9.mail.MessagingException {\r\n    java.lang.String rootIdString = java.lang.Long.toString(rootId);\r\n    com.fsck.k9.search.LocalSearch search = new com.fsck.k9.search.LocalSearch();\r\n    search.and(com.fsck.k9.search.SearchSpecification.SearchField.THREAD_ID, rootIdString, com.fsck.k9.search.SearchSpecification.Attribute.EQUALS);\r\n    return searchForMessages(null, search);\r\n}",
        "name": "getMessagesInThread(long)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.mailstore.DatabasePreviewType": [
      {
        "visibility": "public",
        "simpleName": "fromDatabaseValue(java.lang.String)",
        "qualifiedName": "com.fsck.k9.mailstore.DatabasePreviewType.fromDatabaseValue(java.lang.String)",
        "kind": "method",
        "sourceText": "public static com.fsck.k9.mailstore.DatabasePreviewType fromDatabaseValue(java.lang.String databaseValue) {\r\n    for (com.fsck.k9.mailstore.DatabasePreviewType databasePreviewType : com.fsck.k9.mailstore.DatabasePreviewType.values()) {\r\n        if (databasePreviewType.getDatabaseValue().equals(databaseValue)) {\r\n            return databasePreviewType;\r\n        }\r\n    }\r\n    throw new java.lang.AssertionError(\"Unknown database value: \" + databaseValue);\r\n}",
        "name": "fromDatabaseValue(java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "fromPreviewType(com.fsck.k9.message.extractors.PreviewResult$PreviewType)",
        "qualifiedName": "com.fsck.k9.mailstore.DatabasePreviewType.fromPreviewType(com.fsck.k9.message.extractors.PreviewResult$PreviewType)",
        "kind": "method",
        "sourceText": "public static com.fsck.k9.mailstore.DatabasePreviewType fromPreviewType(com.fsck.k9.message.extractors.PreviewResult.PreviewType previewType) {\r\n    for (com.fsck.k9.mailstore.DatabasePreviewType databasePreviewType : com.fsck.k9.mailstore.DatabasePreviewType.values()) {\r\n        if (databasePreviewType.previewType == previewType) {\r\n            return databasePreviewType;\r\n        }\r\n    }\r\n    throw new java.lang.AssertionError(\"Unknown preview type: \" + previewType);\r\n}",
        "name": "fromPreviewType(com.fsck.k9.message.extractors.PreviewResult$PreviewType)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.mailstore.migrations": {
    "com.fsck.k9.mailstore.migrations.MigrationTo55": [],
    "com.fsck.k9.mailstore.migrations.MigrationTo60": [
      {
        "visibility": "public",
        "simpleName": "migratePendingCommands(android.database.sqlite.SQLiteDatabase)",
        "qualifiedName": "com.fsck.k9.mailstore.migrations.MigrationTo60.migratePendingCommands(android.database.sqlite.SQLiteDatabase)",
        "kind": "method",
        "sourceText": "public static void migratePendingCommands(android.database.sqlite.SQLiteDatabase db) {\r\n    java.util.List<com.fsck.k9.controller.MessagingControllerCommands.PendingCommand> pendingCommands = new java.util.ArrayList<>();\r\n    if (com.fsck.k9.mailstore.migrations.MigrationTo60.columnExists(db, \"pending_commands\", \"arguments\")) {\r\n        for (com.fsck.k9.mailstore.migrations.MigrationTo60.OldPendingCommand oldPendingCommand : com.fsck.k9.mailstore.migrations.MigrationTo60.getPendingCommands(db)) {\r\n            com.fsck.k9.controller.MessagingControllerCommands.PendingCommand newPendingCommand = com.fsck.k9.mailstore.migrations.MigrationTo60.migratePendingCommand(oldPendingCommand);\r\n            pendingCommands.add(newPendingCommand);\r\n        }\r\n        db.execSQL(\"DROP TABLE IF EXISTS pending_commands\");\r\n        db.execSQL(\"CREATE TABLE pending_commands (\" + (((\"id INTEGER PRIMARY KEY, \" + \"command TEXT, \") + \"data TEXT\") + \")\"));\r\n        com.fsck.k9.controller.PendingCommandSerializer pendingCommandSerializer = com.fsck.k9.controller.PendingCommandSerializer.getInstance();\r\n        for (com.fsck.k9.controller.MessagingControllerCommands.PendingCommand pendingCommand : pendingCommands) {\r\n            android.content.ContentValues cv = new android.content.ContentValues();\r\n            cv.put(\"command\", pendingCommand.getCommandName());\r\n            cv.put(\"data\", pendingCommandSerializer.serialize(pendingCommand));\r\n            db.insert(\"pending_commands\", \"command\", cv);\r\n        }\r\n    }\r\n}",
        "name": "migratePendingCommands(android.database.sqlite.SQLiteDatabase)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.mailstore.migrations.MigrationTo52": []
  },
  "com.fsck.k9.mailstore.util": {
    "com.fsck.k9.mailstore.util.FileFactory": [],
    "com.fsck.k9.mailstore.util.FlowedMessageUtils": [
      {
        "visibility": "public",
        "simpleName": "isAlphaChar(java.lang.String,int)",
        "qualifiedName": "com.fsck.k9.mailstore.util.FlowedMessageUtils.isAlphaChar(java.lang.String,int)",
        "kind": "method",
        "sourceText": "/**\r\n * Checks whether the char is part of a word.\r\n * <p>RFC assert a word cannot be split (even if the length is greater than the maximum length).\r\n */\r\npublic static boolean isAlphaChar(java.lang.String text, int index) {\r\n    // Note: a list of chars is available here:\r\n    // http://www.zvon.org/tmRFC/RFC2646/Output/index.html\r\n    char c = text.charAt(index);\r\n    return (((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'))) || ((c >= '0') && (c <= '9'));\r\n}",
        "name": "isAlphaChar(java.lang.String,int)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.mailstore.util.DeferredFileOutputStream": []
  },
  "com.fsck.k9.message": {
    "com.fsck.k9.message.QuotedTextMode": [],
    "com.fsck.k9.message.IdentityHeaderBuilder": [],
    "com.fsck.k9.message.MessageBuilder": [
      {
        "visibility": "public",
        "simpleName": "buildAsync(com.fsck.k9.message.MessageBuilder$Callback)",
        "qualifiedName": "com.fsck.k9.message.MessageBuilder.buildAsync(com.fsck.k9.message.MessageBuilder$Callback)",
        "kind": "method",
        "sourceText": "/**\r\n * This method builds the message asynchronously, calling *exactly one* of the methods\r\n * on the callback on the UI thread after it finishes. The callback may thread-safely\r\n * be detached and reattached intermittently.\r\n */\r\npublic final void buildAsync(com.fsck.k9.message.MessageBuilder.Callback callback) {\r\n    synchronized(callbackLock) {\r\n        asyncCallback = callback;\r\n        queuedMimeMessage = null;\r\n        queuedException = null;\r\n        queuedPendingIntent = null;\r\n    }\r\n    new android.os.AsyncTask<java.lang.Void, java.lang.Void, java.lang.Void>() {\r\n        @java.lang.Override\r\n        protected java.lang.Void doInBackground(java.lang.Void... params) {\r\n            buildMessageInternal();\r\n            return null;\r\n        }\r\n\r\n        @java.lang.Override\r\n        protected void onPostExecute(java.lang.Void aVoid) {\r\n            deliverResult();\r\n        }\r\n    }.execute();\r\n}",
        "name": "buildAsync(com.fsck.k9.message.MessageBuilder$Callback)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "reattachCallback(com.fsck.k9.message.MessageBuilder$Callback)",
        "qualifiedName": "com.fsck.k9.message.MessageBuilder.reattachCallback(com.fsck.k9.message.MessageBuilder$Callback)",
        "kind": "method",
        "sourceText": "/**\r\n * This method attaches a new callback, and must only be called after a previous one was\r\n * detached. If the computation finished while the callback was detached, it will be\r\n * delivered immediately upon reattachment.\r\n */\r\npublic final void reattachCallback(com.fsck.k9.message.MessageBuilder.Callback callback) {\r\n    synchronized(callbackLock) {\r\n        if (asyncCallback != null) {\r\n            throw new java.lang.IllegalStateException(\"need to detach callback before new one can be attached!\");\r\n        }\r\n        asyncCallback = callback;\r\n        deliverResult();\r\n    }\r\n}",
        "name": "reattachCallback(com.fsck.k9.message.MessageBuilder$Callback)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onActivityResult(int,int,android.content.Intent,com.fsck.k9.message.MessageBuilder$Callback)",
        "qualifiedName": "com.fsck.k9.message.MessageBuilder.onActivityResult(int,int,android.content.Intent,com.fsck.k9.message.MessageBuilder$Callback)",
        "kind": "method",
        "sourceText": "public final void onActivityResult(final int requestCode, int resultCode, final android.content.Intent data, com.fsck.k9.message.MessageBuilder.Callback callback) {\r\n    synchronized(callbackLock) {\r\n        asyncCallback = callback;\r\n        queuedMimeMessage = null;\r\n        queuedException = null;\r\n        queuedPendingIntent = null;\r\n    }\r\n    if (resultCode != android.app.Activity.RESULT_OK) {\r\n        asyncCallback.onMessageBuildCancel();\r\n        return;\r\n    }\r\n    new android.os.AsyncTask<java.lang.Void, java.lang.Void, java.lang.Void>() {\r\n        @java.lang.Override\r\n        protected java.lang.Void doInBackground(java.lang.Void... params) {\r\n            buildMessageOnActivityResult(requestCode, data);\r\n            return null;\r\n        }\r\n\r\n        @java.lang.Override\r\n        protected void onPostExecute(java.lang.Void aVoid) {\r\n            deliverResult();\r\n        }\r\n    }.execute();\r\n}",
        "name": "onActivityResult(int,int,android.content.Intent,com.fsck.k9.message.MessageBuilder$Callback)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.message.extractors": {
    "com.fsck.k9.message.extractors.AttachmentCounter": [
      {
        "visibility": "public",
        "simpleName": "newInstance()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.message.extractors.AttachmentCounter.newInstance()",
        "sourceText": "public static com.fsck.k9.message.extractors.AttachmentCounter newInstance() {\r\n    com.fsck.k9.message.extractors.TextPartFinder textPartFinder = new com.fsck.k9.message.extractors.TextPartFinder();\r\n    com.fsck.k9.message.extractors.EncryptionDetector encryptionDetector = new com.fsck.k9.message.extractors.EncryptionDetector(textPartFinder);\r\n    return new com.fsck.k9.message.extractors.AttachmentCounter(encryptionDetector);\r\n}",
        "name": "newInstance()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getAttachmentCount(com.fsck.k9.mail.Message)",
        "qualifiedName": "com.fsck.k9.message.extractors.AttachmentCounter.getAttachmentCount(com.fsck.k9.mail.Message)",
        "kind": "method",
        "sourceText": "public int getAttachmentCount(com.fsck.k9.mail.Message message) throws com.fsck.k9.mail.MessagingException {\r\n    if (encryptionDetector.isEncrypted(message)) {\r\n        return 0;\r\n    }\r\n    java.util.List<com.fsck.k9.mail.Part> attachmentParts = new java.util.ArrayList<>();\r\n    com.fsck.k9.mail.internet.MessageExtractor.findViewablesAndAttachments(message, null, attachmentParts);\r\n    return attachmentParts.size();\r\n}",
        "name": "getAttachmentCount(com.fsck.k9.mail.Message)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.message.extractors.PreviewResult": [],
    "com.fsck.k9.message.extractors.AttachmentInfoExtractor": [
      {
        "visibility": "public",
        "simpleName": "extractAttachmentInfoForView(java.util.List)",
        "qualifiedName": "com.fsck.k9.message.extractors.AttachmentInfoExtractor.extractAttachmentInfoForView(java.util.List)",
        "kind": "method",
        "sourceText": "@android.support.annotation.WorkerThread\r\npublic java.util.List<com.fsck.k9.mailstore.AttachmentViewInfo> extractAttachmentInfoForView(java.util.List<com.fsck.k9.mail.Part> attachmentParts) throws com.fsck.k9.mail.MessagingException {\r\n    java.util.List<com.fsck.k9.mailstore.AttachmentViewInfo> attachments = new java.util.ArrayList<>();\r\n    for (com.fsck.k9.mail.Part part : attachmentParts) {\r\n        com.fsck.k9.mailstore.AttachmentViewInfo attachmentViewInfo = extractAttachmentInfo(part);\r\n        attachments.add(attachmentViewInfo);\r\n    }\r\n    return attachments;\r\n}",
        "name": "extractAttachmentInfoForView(java.util.List)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "extractAttachmentInfoForDatabase(com.fsck.k9.mail.Part)",
        "qualifiedName": "com.fsck.k9.message.extractors.AttachmentInfoExtractor.extractAttachmentInfoForDatabase(com.fsck.k9.mail.Part)",
        "kind": "method",
        "sourceText": "public com.fsck.k9.mailstore.AttachmentViewInfo extractAttachmentInfoForDatabase(com.fsck.k9.mail.Part part) throws com.fsck.k9.mail.MessagingException {\r\n    boolean isContentAvailable = part.getBody() != null;\r\n    return extractAttachmentInfo(part, Uri.EMPTY, com.fsck.k9.mailstore.AttachmentViewInfo.UNKNOWN_SIZE, isContentAvailable);\r\n}",
        "name": "extractAttachmentInfoForDatabase(com.fsck.k9.mail.Part)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "extractAttachmentInfo(com.fsck.k9.mail.Part)",
        "qualifiedName": "com.fsck.k9.message.extractors.AttachmentInfoExtractor.extractAttachmentInfo(com.fsck.k9.mail.Part)",
        "kind": "method",
        "sourceText": "@android.support.annotation.WorkerThread\r\npublic com.fsck.k9.mailstore.AttachmentViewInfo extractAttachmentInfo(com.fsck.k9.mail.Part part) throws com.fsck.k9.mail.MessagingException {\r\n    android.net.Uri uri;\r\n    long size;\r\n    boolean isContentAvailable;\r\n    if (part instanceof com.fsck.k9.mailstore.LocalPart) {\r\n        com.fsck.k9.mailstore.LocalPart localPart = ((com.fsck.k9.mailstore.LocalPart) (part));\r\n        java.lang.String accountUuid = localPart.getAccountUuid();\r\n        long messagePartId = localPart.getPartId();\r\n        size = localPart.getSize();\r\n        isContentAvailable = part.getBody() != null;\r\n        uri = com.fsck.k9.provider.AttachmentProvider.getAttachmentUri(accountUuid, messagePartId);\r\n    } else if (part instanceof com.fsck.k9.mailstore.LocalMessage) {\r\n        com.fsck.k9.mailstore.LocalMessage localMessage = ((com.fsck.k9.mailstore.LocalMessage) (part));\r\n        java.lang.String accountUuid = localMessage.getAccount().getUuid();\r\n        long messagePartId = localMessage.getMessagePartId();\r\n        size = localMessage.getSize();\r\n        isContentAvailable = part.getBody() != null;\r\n        uri = com.fsck.k9.provider.AttachmentProvider.getAttachmentUri(accountUuid, messagePartId);\r\n    } else {\r\n        com.fsck.k9.mail.Body body = part.getBody();\r\n        if (body instanceof com.fsck.k9.mailstore.DeferredFileBody) {\r\n            com.fsck.k9.mailstore.DeferredFileBody decryptedTempFileBody = ((com.fsck.k9.mailstore.DeferredFileBody) (body));\r\n            size = decryptedTempFileBody.getSize();\r\n            uri = getDecryptedFileProviderUri(decryptedTempFileBody, part.getMimeType());\r\n            isContentAvailable = true;\r\n        } else {\r\n            throw new java.lang.IllegalArgumentException(\"Unsupported part type provided\");\r\n        }\r\n    }\r\n    return extractAttachmentInfo(part, uri, size, isContentAvailable);\r\n}",
        "name": "extractAttachmentInfo(com.fsck.k9.mail.Part)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.message.html": {
    "com.fsck.k9.message.html.HttpUriParser": [
      {
        "visibility": "public",
        "simpleName": "linkifyUri(java.lang.String,int,java.lang.StringBuffer)",
        "qualifiedName": "com.fsck.k9.message.html.HttpUriParser.linkifyUri(java.lang.String,int,java.lang.StringBuffer)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic int linkifyUri(java.lang.String text, int startPos, java.lang.StringBuffer outputBuffer) {\r\n    int currentPos = startPos;\r\n    // Scheme\r\n    java.lang.String shortScheme = text.substring(currentPos, java.lang.Math.min(currentPos + 7, text.length()));\r\n    java.lang.String longScheme = text.substring(currentPos, java.lang.Math.min(currentPos + 8, text.length()));\r\n    if (longScheme.equalsIgnoreCase(\"https://\")) {\r\n        currentPos += \"https://\".length();\r\n    } else if (shortScheme.equalsIgnoreCase(\"http://\")) {\r\n        currentPos += \"http://\".length();\r\n    } else if (shortScheme.equalsIgnoreCase(\"rtsp://\")) {\r\n        currentPos += \"rtsp://\".length();\r\n    } else {\r\n        return startPos;\r\n    }\r\n    // Authority\r\n    int matchedAuthorityEnd = tryMatchAuthority(text, currentPos);\r\n    if (matchedAuthorityEnd == currentPos) {\r\n        return startPos;\r\n    }\r\n    currentPos = matchedAuthorityEnd;\r\n    // Path\r\n    if ((currentPos < text.length()) && (text.charAt(currentPos) == '/')) {\r\n        currentPos = matchUnreservedPCTEncodedSubDelimClassesGreedy(text, currentPos + 1, \"/:@\");\r\n    }\r\n    // Query\r\n    if ((currentPos < text.length()) && (text.charAt(currentPos) == '?')) {\r\n        currentPos = matchUnreservedPCTEncodedSubDelimClassesGreedy(text, currentPos + 1, \":@/?\");\r\n    }\r\n    // Fragment\r\n    if ((currentPos < text.length()) && (text.charAt(currentPos) == '#')) {\r\n        currentPos = matchUnreservedPCTEncodedSubDelimClassesGreedy(text, currentPos + 1, \":@/?\");\r\n    }\r\n    java.lang.String httpUri = text.substring(startPos, currentPos);\r\n    outputBuffer.append(\"<a href=\\\"\").append(httpUri).append(\"\\\">\").append(httpUri).append(\"</a>\");\r\n    return currentPos;\r\n}",
        "name": "linkifyUri(java.lang.String,int,java.lang.StringBuffer)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.message.html.HtmlConverter": [
      {
        "visibility": "public",
        "simpleName": "convertEmoji2Img(java.lang.String)",
        "qualifiedName": "com.fsck.k9.message.html.HtmlConverter.convertEmoji2Img(java.lang.String)",
        "kind": "method",
        "sourceText": "public static java.lang.String convertEmoji2Img(java.lang.String html) {\r\n    if (!com.fsck.k9.message.html.HtmlConverter.hasEmoji(html)) {\r\n        return html;\r\n    }\r\n    java.lang.StringBuilder buff = new java.lang.StringBuilder(html.length() + 512);\r\n    for (int i = 0; i < html.length(); i = html.offsetByCodePoints(i, 1)) {\r\n        int codePoint = html.codePointAt(i);\r\n        java.lang.String emoji = com.fsck.k9.message.html.HtmlConverter.getEmojiForCodePoint(codePoint);\r\n        if (emoji != null) {\r\n            buff.append(\"<img src=\\\"file:///android_asset/emoticons/\").append(emoji).append(\".gif\\\" alt=\\\"\").append(emoji).append(\"\\\" />\");\r\n        } else {\r\n            buff.appendCodePoint(codePoint);\r\n        }\r\n    }\r\n    return buff.toString();\r\n}",
        "name": "convertEmoji2Img(java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "textToHtmlFragment(java.lang.String)",
        "qualifiedName": "com.fsck.k9.message.html.HtmlConverter.textToHtmlFragment(java.lang.String)",
        "kind": "method",
        "sourceText": "/**\r\n * Convert a plain text string into an HTML fragment.\r\n *\r\n * @param text\r\n * \t\tPlain text.\r\n * @return HTML fragment.\r\n */\r\npublic static java.lang.String textToHtmlFragment(final java.lang.String text) {\r\n    // Escape the entities and add newlines.\r\n    java.lang.String htmlified = android.text.TextUtils.htmlEncode(text);\r\n    // Linkify the message.\r\n    java.lang.StringBuffer linkified = new java.lang.StringBuffer(htmlified.length() + com.fsck.k9.message.html.HtmlConverter.TEXT_TO_HTML_EXTRA_BUFFER_LENGTH);\r\n    com.fsck.k9.message.html.UriLinkifier.linkifyText(htmlified, linkified);\r\n    // Add newlines and unescaping.\r\n    // \r\n    // For some reason, TextUtils.htmlEncode escapes ' into &apos;, which is technically part of the XHTML 1.0\r\n    // standard, but Gmail doesn't recognize it as an HTML entity. We unescape that here.\r\n    return linkified.toString().replaceAll(\"\\r?\\n\", \"<br>\\r\\n\").replace(\"&apos;\", \"&#39;\");\r\n}",
        "name": "textToHtmlFragment(java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "wrapMessageContent(java.lang.CharSequence)",
        "qualifiedName": "com.fsck.k9.message.html.HtmlConverter.wrapMessageContent(java.lang.CharSequence)",
        "kind": "method",
        "sourceText": "public static java.lang.String wrapMessageContent(java.lang.CharSequence messageContent) {\r\n    // Include a meta tag so the WebView will not use a fixed viewport width of 980 px\r\n    return ((((\"<html><head><meta name=\\\"viewport\\\" content=\\\"width=device-width\\\"/>\" + com.fsck.k9.message.html.HtmlConverter.cssStyleTheme()) + com.fsck.k9.message.html.HtmlConverter.cssStylePre()) + \"</head><body>\") + messageContent) + \"</body></html>\";\r\n}",
        "name": "wrapMessageContent(java.lang.CharSequence)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "htmlToSpanned(java.lang.String)",
        "qualifiedName": "com.fsck.k9.message.html.HtmlConverter.htmlToSpanned(java.lang.String)",
        "kind": "method",
        "sourceText": "/**\r\n * Convert HTML to a {@link Spanned} that can be used in a {@link android.widget.TextView}.\r\n *\r\n * @param html\r\n * \t\tThe HTML fragment to be converted.\r\n * @return A {@link Spanned} containing the text in {@code html} formatted using spans.\r\n */\r\npublic static android.text.Spanned htmlToSpanned(java.lang.String html) {\r\n    return android.text.Html.fromHtml(html, null, new com.fsck.k9.message.html.HtmlConverter.ListTagHandler());\r\n}",
        "name": "htmlToSpanned(java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "htmlToText(java.lang.String)",
        "qualifiedName": "com.fsck.k9.message.html.HtmlConverter.htmlToText(java.lang.String)",
        "kind": "method",
        "sourceText": "/**\r\n * Convert an HTML string to a plain text string.\r\n *\r\n * @param html\r\n * \t\tHTML string to convert.\r\n * @return Plain text result.\r\n */\r\npublic static java.lang.String htmlToText(final java.lang.String html) {\r\n    return android.text.Html.fromHtml(html, null, new com.fsck.k9.message.html.HtmlConverter.HtmlToTextTagHandler()).toString().replace(com.fsck.k9.message.html.HtmlConverter.PREVIEW_OBJECT_CHARACTER, com.fsck.k9.message.html.HtmlConverter.PREVIEW_OBJECT_REPLACEMENT).replace(com.fsck.k9.message.html.HtmlConverter.NBSP_CHARACTER, com.fsck.k9.message.html.HtmlConverter.NBSP_REPLACEMENT);\r\n}",
        "name": "htmlToText(java.lang.String)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.message.html.HeadCleaner": []
  },
  "com.fsck.k9.message.quote": {
    "com.fsck.k9.message.quote.InsertableHtmlContent": [
      {
        "visibility": "public",
        "simpleName": "insertIntoQuotedFooter(java.lang.String)",
        "qualifiedName": "com.fsck.k9.message.quote.InsertableHtmlContent.insertIntoQuotedFooter(java.lang.String)",
        "kind": "method",
        "sourceText": "/**\r\n * <p>Insert something into the quoted content footer. This is typically used for inserting closing\r\n * tags of reply/forward headers rather than inserting the user-generated reply content.</p>\r\n *\r\n * <p>Subsequent calls to {@link #insertIntoQuotedFooter(String)} will <b>append</b> text onto any\r\n * existing footer and quoted content.</p>\r\n *\r\n * @param content\r\n * \t\tContent to add.\r\n */\r\npublic void insertIntoQuotedFooter(final java.lang.String content) {\r\n    quotedContent.insert(footerInsertionPoint, content);\r\n    // Update the location of the footer insertion point to the end of the inserted content.\r\n    footerInsertionPoint += content.length();\r\n}",
        "name": "insertIntoQuotedFooter(java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "setInsertionLocation(com.fsck.k9.message.quote.InsertableHtmlContent$InsertionLocation)",
        "qualifiedName": "com.fsck.k9.message.quote.InsertableHtmlContent.setInsertionLocation(com.fsck.k9.message.quote.InsertableHtmlContent$InsertionLocation)",
        "kind": "method",
        "sourceText": "/**\r\n * Configure where user content should be inserted, either before or after the quoted content.\r\n *\r\n * @param insertionLocation\r\n * \t\tWhere to insert user content.\r\n */\r\npublic void setInsertionLocation(final com.fsck.k9.message.quote.InsertableHtmlContent.InsertionLocation insertionLocation) {\r\n    this.insertionLocation = insertionLocation;\r\n}",
        "name": "setInsertionLocation(com.fsck.k9.message.quote.InsertableHtmlContent$InsertionLocation)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "toDebugString()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.message.quote.InsertableHtmlContent.toDebugString()",
        "sourceText": "/**\r\n * Return debugging information for this container.\r\n *\r\n * @return Debug string.\r\n */\r\npublic java.lang.String toDebugString() {\r\n    return ((((((((((((\"InsertableHtmlContent{\" + \"headerInsertionPoint=\") + headerInsertionPoint) + \", footerInsertionPoint=\") + footerInsertionPoint) + \", insertionLocation=\") + insertionLocation) + \", quotedContent=\") + quotedContent) + \", userContent=\") + userContent) + \", compiledResult=\") + toString()) + '}';\r\n}",
        "name": "toDebugString()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getInsertionPoint()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.message.quote.InsertableHtmlContent.getInsertionPoint()",
        "sourceText": "/**\r\n * Fetch the insertion point based upon the quote style.\r\n *\r\n * @return Insertion point\r\n */\r\npublic int getInsertionPoint() {\r\n    if (insertionLocation == com.fsck.k9.message.quote.InsertableHtmlContent.InsertionLocation.BEFORE_QUOTE) {\r\n        return headerInsertionPoint;\r\n    } else {\r\n        return footerInsertionPoint;\r\n    }\r\n}",
        "name": "getInsertionPoint()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "toString()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.message.quote.InsertableHtmlContent.toString()",
        "sourceText": "/**\r\n * Build the composed string with the inserted and original content.\r\n *\r\n * @return Composed string.\r\n */\r\n@java.lang.Override\r\npublic java.lang.String toString() {\r\n    final int insertionPoint = getInsertionPoint();\r\n    // Inserting and deleting was twice as fast as instantiating a new StringBuilder and\r\n    // using substring() to build the new pieces.\r\n    java.lang.String result = quotedContent.insert(insertionPoint, userContent.toString()).toString();\r\n    quotedContent.delete(insertionPoint, insertionPoint + userContent.length());\r\n    return result;\r\n}",
        "name": "toString()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "insertIntoQuotedHeader(java.lang.String)",
        "qualifiedName": "com.fsck.k9.message.quote.InsertableHtmlContent.insertIntoQuotedHeader(java.lang.String)",
        "kind": "method",
        "sourceText": "/**\r\n * <p>Insert something into the quoted content header. This is typically used for inserting\r\n * reply/forward headers into the quoted content rather than inserting the user-generated reply\r\n * content.</p>\r\n *\r\n * <p>Subsequent calls to {@link #insertIntoQuotedHeader(String)} will <b>prepend</b> text onto any\r\n * existing header and quoted content.</p>\r\n *\r\n * @param content\r\n * \t\tContent to add.\r\n */\r\npublic void insertIntoQuotedHeader(final java.lang.String content) {\r\n    quotedContent.insert(headerInsertionPoint, content);\r\n    // Update the location of the footer insertion point.\r\n    footerInsertionPoint += content.length();\r\n}",
        "name": "insertIntoQuotedHeader(java.lang.String)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.message.quote.TextQuoteCreator": [],
    "com.fsck.k9.message.quote.QuoteHelper": []
  },
  "com.fsck.k9.message.signature": {
    "com.fsck.k9.message.signature.HtmlSignatureRemover": [],
    "com.fsck.k9.message.signature.TextSignatureRemover": [
      {
        "visibility": "public",
        "simpleName": "stripSignature(java.lang.String)",
        "qualifiedName": "com.fsck.k9.message.signature.TextSignatureRemover.stripSignature(java.lang.String)",
        "kind": "method",
        "sourceText": "public static java.lang.String stripSignature(java.lang.String content) {\r\n    if (com.fsck.k9.message.signature.TextSignatureRemover.DASH_SIGNATURE_PLAIN.matcher(content).find()) {\r\n        content = com.fsck.k9.message.signature.TextSignatureRemover.DASH_SIGNATURE_PLAIN.matcher(content).replaceFirst(\"\\r\\n\");\r\n    }\r\n    return content;\r\n}",
        "name": "stripSignature(java.lang.String)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.notification": {
    "com.fsck.k9.notification.NewMailNotifications": [
      {
        "visibility": "public",
        "simpleName": "removeNewMailNotification(com.fsck.k9.Account,com.fsck.k9.activity.MessageReference)",
        "qualifiedName": "com.fsck.k9.notification.NewMailNotifications.removeNewMailNotification(com.fsck.k9.Account,com.fsck.k9.activity.MessageReference)",
        "kind": "method",
        "sourceText": "public void removeNewMailNotification(com.fsck.k9.Account account, com.fsck.k9.activity.MessageReference messageReference) {\r\n    synchronized(lock) {\r\n        com.fsck.k9.notification.NotificationData notificationData = getNotificationData(account);\r\n        if (notificationData == null) {\r\n            return;\r\n        }\r\n        com.fsck.k9.notification.RemoveNotificationResult result = notificationData.removeNotificationForMessage(messageReference);\r\n        if (result.isUnknownNotification()) {\r\n            return;\r\n        }\r\n        cancelNotification(result.getNotificationId());\r\n        if (result.shouldCreateNotification()) {\r\n            createStackedNotification(account, result.getNotificationHolder());\r\n        }\r\n        updateSummaryNotification(account, notificationData);\r\n    }\r\n}",
        "name": "removeNewMailNotification(com.fsck.k9.Account,com.fsck.k9.activity.MessageReference)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "addNewMailNotification(com.fsck.k9.Account,com.fsck.k9.mailstore.LocalMessage,int)",
        "qualifiedName": "com.fsck.k9.notification.NewMailNotifications.addNewMailNotification(com.fsck.k9.Account,com.fsck.k9.mailstore.LocalMessage,int)",
        "kind": "method",
        "sourceText": "public void addNewMailNotification(com.fsck.k9.Account account, com.fsck.k9.mailstore.LocalMessage message, int unreadMessageCount) {\r\n    com.fsck.k9.notification.NotificationContent content = contentCreator.createFromMessage(account, message);\r\n    synchronized(lock) {\r\n        com.fsck.k9.notification.NotificationData notificationData = getOrCreateNotificationData(account, unreadMessageCount);\r\n        com.fsck.k9.notification.AddNotificationResult result = notificationData.addNotificationContent(content);\r\n        if (result.shouldCancelNotification()) {\r\n            int notificationId = result.getNotificationId();\r\n            cancelNotification(notificationId);\r\n        }\r\n        createStackedNotification(account, result.getNotificationHolder());\r\n        createSummaryNotification(account, notificationData, false);\r\n    }\r\n}",
        "name": "addNewMailNotification(com.fsck.k9.Account,com.fsck.k9.mailstore.LocalMessage,int)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "clearNewMailNotifications(com.fsck.k9.Account)",
        "qualifiedName": "com.fsck.k9.notification.NewMailNotifications.clearNewMailNotifications(com.fsck.k9.Account)",
        "kind": "method",
        "sourceText": "public void clearNewMailNotifications(com.fsck.k9.Account account) {\r\n    com.fsck.k9.notification.NotificationData notificationData;\r\n    synchronized(lock) {\r\n        notificationData = removeNotificationData(account);\r\n    }\r\n    if (notificationData == null) {\r\n        return;\r\n    }\r\n    for (int notificationId : notificationData.getActiveNotificationIds()) {\r\n        cancelNotification(notificationId);\r\n    }\r\n    int notificationId = com.fsck.k9.notification.NotificationIds.getNewMailSummaryNotificationId(account);\r\n    cancelNotification(notificationId);\r\n}",
        "name": "clearNewMailNotifications(com.fsck.k9.Account)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "newInstance(com.fsck.k9.notification.NotificationController,com.fsck.k9.notification.NotificationActionCreator)",
        "qualifiedName": "com.fsck.k9.notification.NewMailNotifications.newInstance(com.fsck.k9.notification.NotificationController,com.fsck.k9.notification.NotificationActionCreator)",
        "kind": "method",
        "sourceText": "public static com.fsck.k9.notification.NewMailNotifications newInstance(com.fsck.k9.notification.NotificationController controller, com.fsck.k9.notification.NotificationActionCreator actionCreator) {\r\n    com.fsck.k9.notification.NotificationContentCreator contentCreator = new com.fsck.k9.notification.NotificationContentCreator(controller.getContext());\r\n    com.fsck.k9.notification.WearNotifications wearNotifications = new com.fsck.k9.notification.WearNotifications(controller, actionCreator);\r\n    com.fsck.k9.notification.DeviceNotifications deviceNotifications = com.fsck.k9.notification.DeviceNotifications.newInstance(controller, actionCreator, wearNotifications);\r\n    return new com.fsck.k9.notification.NewMailNotifications(controller, contentCreator, deviceNotifications, wearNotifications);\r\n}",
        "name": "newInstance(com.fsck.k9.notification.NotificationController,com.fsck.k9.notification.NotificationActionCreator)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.notification.SendFailedNotifications": [
      {
        "visibility": "public",
        "simpleName": "showSendFailedNotification(com.fsck.k9.Account,java.lang.Exception)",
        "qualifiedName": "com.fsck.k9.notification.SendFailedNotifications.showSendFailedNotification(com.fsck.k9.Account,java.lang.Exception)",
        "kind": "method",
        "sourceText": "public void showSendFailedNotification(com.fsck.k9.Account account, java.lang.Exception exception) {\r\n    android.content.Context context = controller.getContext();\r\n    java.lang.String title = context.getString(R.string.send_failure_subject);\r\n    java.lang.String text = com.fsck.k9.helper.ExceptionHelper.getRootCauseMessage(exception);\r\n    int notificationId = com.fsck.k9.notification.NotificationIds.getSendFailedNotificationId(account);\r\n    android.app.PendingIntent folderListPendingIntent = actionBuilder.createViewFolderListPendingIntent(account, notificationId);\r\n    android.support.v4.app.NotificationCompat.Builder builder = controller.createNotificationBuilder().setSmallIcon(getSendFailedNotificationIcon()).setWhen(java.lang.System.currentTimeMillis()).setAutoCancel(true).setTicker(title).setContentTitle(title).setContentText(text).setContentIntent(folderListPendingIntent).setVisibility(NotificationCompat.VISIBILITY_PUBLIC).setCategory(NotificationCompat.CATEGORY_ERROR);\r\n    controller.configureNotification(builder, null, null, com.fsck.k9.notification.NotificationController.NOTIFICATION_LED_FAILURE_COLOR, com.fsck.k9.notification.NotificationController.NOTIFICATION_LED_BLINK_FAST, true);\r\n    getNotificationManager().notify(notificationId, builder.build());\r\n}",
        "name": "showSendFailedNotification(com.fsck.k9.Account,java.lang.Exception)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.notification.NotificationContent": []
  },
  "com.fsck.k9.power": {
    "com.fsck.k9.power.DeviceIdleReceiver": [
      {
        "visibility": "public",
        "simpleName": "onReceive(android.content.Context,android.content.Intent)",
        "qualifiedName": "com.fsck.k9.power.DeviceIdleReceiver.onReceive(android.content.Context,android.content.Intent)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic void onReceive(android.content.Context context, android.content.Intent intent) {\r\n    boolean deviceInIdleMode = powerManager.isDeviceIdleMode();\r\n    timber.log.Timber.v(\"Device idle mode changed. Idle: %b\", deviceInIdleMode);\r\n    if (!deviceInIdleMode) {\r\n        com.fsck.k9.service.MailService.actionReset(context, null);\r\n    }\r\n}",
        "name": "onReceive(android.content.Context,android.content.Intent)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.power.DozeChecker": [],
    "com.fsck.k9.power.DeviceIdleManager": [
      {
        "visibility": "public",
        "simpleName": "getInstance(android.content.Context)",
        "qualifiedName": "com.fsck.k9.power.DeviceIdleManager.getInstance(android.content.Context)",
        "kind": "method",
        "sourceText": "public static synchronized com.fsck.k9.power.DeviceIdleManager getInstance(android.content.Context context) {\r\n    if (com.fsck.k9.power.DeviceIdleManager.instance == null) {\r\n        com.fsck.k9.power.DozeChecker dozeChecker = new com.fsck.k9.power.DozeChecker(context);\r\n        if (dozeChecker.isDeviceIdleModeSupported() && (!dozeChecker.isAppWhitelisted())) {\r\n            com.fsck.k9.power.DeviceIdleManager.instance = com.fsck.k9.power.DeviceIdleManager.RealDeviceIdleManager.newInstance(context);\r\n        } else {\r\n            com.fsck.k9.power.DeviceIdleManager.instance = new com.fsck.k9.power.DeviceIdleManager.NoOpDeviceIdleManager();\r\n        }\r\n    }\r\n    return com.fsck.k9.power.DeviceIdleManager.instance;\r\n}",
        "name": "getInstance(android.content.Context)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.preferences": {
    "com.fsck.k9.preferences.IdentitySettings": [
      {
        "visibility": "public",
        "simpleName": "upgrade(int,java.util.Map)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.preferences.IdentitySettings.upgrade(int,java.util.Map)",
        "sourceText": "public static java.util.Set<java.lang.String> upgrade(int version, java.util.Map<java.lang.String, java.lang.Object> validatedSettings) {\r\n    return com.fsck.k9.preferences.Settings.upgrade(version, com.fsck.k9.preferences.IdentitySettings.UPGRADERS, com.fsck.k9.preferences.IdentitySettings.SETTINGS, validatedSettings);\r\n}",
        "name": "upgrade(int,java.util.Map)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.preferences.Storage": [
      {
        "visibility": "public",
        "simpleName": "contains(java.lang.String)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.preferences.Storage.contains(java.lang.String)",
        "sourceText": "public boolean contains(java.lang.String key) {\r\n    // TODO this used to be ConcurrentHashMap#contains which is\r\n    // actually containsValue. But looking at the usage of this method,\r\n    // it's clear that containsKey is what's intended. Investigate if this\r\n    // was a bug previously. Looks like it was only used once, when upgrading\r\n    return storage.containsKey(key);\r\n}",
        "name": "contains(java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getInt(java.lang.String,int)",
        "qualifiedName": "com.fsck.k9.preferences.Storage.getInt(java.lang.String,int)",
        "kind": "method",
        "sourceText": "public int getInt(java.lang.String key, int defValue) {\r\n    java.lang.String val = storage.get(key);\r\n    if (val == null) {\r\n        return defValue;\r\n    }\r\n    try {\r\n        return java.lang.Integer.parseInt(val);\r\n    } catch (java.lang.NumberFormatException nfe) {\r\n        timber.log.Timber.e(nfe, \"Could not parse int\");\r\n        return defValue;\r\n    }\r\n}",
        "name": "getInt(java.lang.String,int)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getLong(java.lang.String,long)",
        "qualifiedName": "com.fsck.k9.preferences.Storage.getLong(java.lang.String,long)",
        "kind": "method",
        "sourceText": "public long getLong(java.lang.String key, long defValue) {\r\n    java.lang.String val = storage.get(key);\r\n    if (val == null) {\r\n        return defValue;\r\n    }\r\n    try {\r\n        return java.lang.Long.parseLong(val);\r\n    } catch (java.lang.NumberFormatException nfe) {\r\n        timber.log.Timber.e(nfe, \"Could not parse long\");\r\n        return defValue;\r\n    }\r\n}",
        "name": "getLong(java.lang.String,long)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getStorage(android.content.Context)",
        "qualifiedName": "com.fsck.k9.preferences.Storage.getStorage(android.content.Context)",
        "kind": "method",
        "sourceText": "public static com.fsck.k9.preferences.Storage getStorage(android.content.Context context) {\r\n    com.fsck.k9.preferences.Storage tmpStorage = com.fsck.k9.preferences.Storage.storages.get(context);\r\n    if (tmpStorage != null) {\r\n        timber.log.Timber.d(\"Returning already existing Storage\");\r\n        return tmpStorage;\r\n    } else {\r\n        timber.log.Timber.d(\"Creating provisional storage\");\r\n        tmpStorage = new com.fsck.k9.preferences.Storage(context);\r\n        com.fsck.k9.preferences.Storage oldStorage = com.fsck.k9.preferences.Storage.storages.putIfAbsent(context, tmpStorage);\r\n        if (oldStorage != null) {\r\n            timber.log.Timber.d(\"Another thread beat us to creating the Storage, returning that one\");\r\n            return oldStorage;\r\n        } else {\r\n            timber.log.Timber.d(\"Returning the Storage we created\");\r\n            return tmpStorage;\r\n        }\r\n    }\r\n}",
        "name": "getStorage(android.content.Context)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.preferences.GlobalSettings": [
      {
        "visibility": "public",
        "simpleName": "upgrade(int,java.util.Map)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.preferences.GlobalSettings.upgrade(int,java.util.Map)",
        "sourceText": "public static java.util.Set<java.lang.String> upgrade(int version, java.util.Map<java.lang.String, java.lang.Object> validatedSettings) {\r\n    return com.fsck.k9.preferences.Settings.upgrade(version, com.fsck.k9.preferences.GlobalSettings.UPGRADERS, com.fsck.k9.preferences.GlobalSettings.SETTINGS, validatedSettings);\r\n}",
        "name": "upgrade(int,java.util.Map)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.provider": {
    "com.fsck.k9.provider.MessageProvider": [
      {
        "visibility": "public",
        "simpleName": "delete(android.net.Uri,java.lang.String,java.lang.String[])",
        "qualifiedName": "com.fsck.k9.provider.MessageProvider.delete(android.net.Uri,java.lang.String,java.lang.String[])",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic int delete(android.net.Uri uri, java.lang.String selection, java.lang.String[] selectionArgs) {\r\n    if (com.fsck.k9.K9.app == null) {\r\n        return 0;\r\n    }\r\n    timber.log.Timber.v(\"MessageProvider/delete: %s\", uri);\r\n    // Note: can only delete a message\r\n    java.util.List<java.lang.String> segments = uri.getPathSegments();\r\n    int accountId = java.lang.Integer.parseInt(segments.get(1));\r\n    java.lang.String folderName = segments.get(2);\r\n    java.lang.String msgUid = segments.get(3);\r\n    // get account\r\n    com.fsck.k9.Account myAccount = null;\r\n    for (com.fsck.k9.Account account : com.fsck.k9.Preferences.getPreferences(getContext()).getAccounts()) {\r\n        if (account.getAccountNumber() == accountId) {\r\n            myAccount = account;\r\n            if (!account.isAvailable(getContext())) {\r\n                timber.log.Timber.w(\"not deleting messages because account is unavailable at the moment\");\r\n                return 0;\r\n            }\r\n        }\r\n    }\r\n    if (myAccount == null) {\r\n        timber.log.Timber.e(\"Could not find account with id %d\", accountId);\r\n    }\r\n    if (myAccount != null) {\r\n        com.fsck.k9.activity.MessageReference messageReference = new com.fsck.k9.activity.MessageReference(myAccount.getUuid(), folderName, msgUid, null);\r\n        com.fsck.k9.controller.MessagingController controller = com.fsck.k9.controller.MessagingController.getInstance(getContext());\r\n        controller.deleteMessage(messageReference, null);\r\n    }\r\n    // FIXME return the actual number of deleted messages\r\n    return 0;\r\n}",
        "name": "delete(android.net.Uri,java.lang.String,java.lang.String[])",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)",
        "qualifiedName": "com.fsck.k9.provider.MessageProvider.query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder) {\r\n    if (com.fsck.k9.K9.app == null) {\r\n        return null;\r\n    }\r\n    timber.log.Timber.v(\"MessageProvider/query: %s\", uri);\r\n    int code = uriMatcher.match(uri);\r\n    if (code == (-1)) {\r\n        throw new java.lang.IllegalStateException(\"Unrecognized URI: \" + uri);\r\n    }\r\n    android.database.Cursor cursor;\r\n    try {\r\n        com.fsck.k9.provider.MessageProvider.QueryHandler handler = queryHandlers.get(code);\r\n        cursor = handler.query(uri, projection, selection, selectionArgs, sortOrder);\r\n    } catch (java.lang.Exception e) {\r\n        timber.log.Timber.e(e, \"Unable to execute query for URI: %s\", uri);\r\n        return null;\r\n    }\r\n    return cursor;\r\n}",
        "name": "query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onCreate()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.provider.MessageProvider.onCreate()",
        "sourceText": "@java.lang.Override\r\npublic boolean onCreate() {\r\n    messageHelper = com.fsck.k9.helper.MessageHelper.getInstance(getContext());\r\n    registerQueryHandler(new com.fsck.k9.provider.MessageProvider.ThrottlingQueryHandler(new com.fsck.k9.provider.MessageProvider.AccountsQueryHandler()));\r\n    registerQueryHandler(new com.fsck.k9.provider.MessageProvider.ThrottlingQueryHandler(new com.fsck.k9.provider.MessageProvider.MessagesQueryHandler()));\r\n    registerQueryHandler(new com.fsck.k9.provider.MessageProvider.ThrottlingQueryHandler(new com.fsck.k9.provider.MessageProvider.UnreadQueryHandler()));\r\n    com.fsck.k9.K9.registerApplicationAware(new com.fsck.k9.K9.ApplicationAware() {\r\n        @java.lang.Override\r\n        public void initializeComponent(final android.app.Application application) {\r\n            timber.log.Timber.v(\"Registering content resolver notifier\");\r\n            com.fsck.k9.controller.MessagingController.getInstance(application).addListener(new com.fsck.k9.controller.SimpleMessagingListener() {\r\n                @java.lang.Override\r\n                public void folderStatusChanged(com.fsck.k9.Account account, java.lang.String folderName, int unreadMessageCount) {\r\n                    application.getContentResolver().notifyChange(com.fsck.k9.provider.MessageProvider.CONTENT_URI, null);\r\n                }\r\n            });\r\n        }\r\n    });\r\n    return true;\r\n}",
        "name": "onCreate()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "update(android.net.Uri,android.content.ContentValues,java.lang.String,java.lang.String[])",
        "qualifiedName": "com.fsck.k9.provider.MessageProvider.update(android.net.Uri,android.content.ContentValues,java.lang.String,java.lang.String[])",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic int update(android.net.Uri uri, android.content.ContentValues values, java.lang.String selection, java.lang.String[] selectionArgs) {\r\n    if (com.fsck.k9.K9.app == null) {\r\n        return 0;\r\n    }\r\n    timber.log.Timber.v(\"MessageProvider/update: %s\", uri);\r\n    // TBD\r\n    return 0;\r\n}",
        "name": "update(android.net.Uri,android.content.ContentValues,java.lang.String,java.lang.String[])",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.provider.AttachmentProvider": [
      {
        "visibility": "public",
        "simpleName": "query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)",
        "qualifiedName": "com.fsck.k9.provider.AttachmentProvider.query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic android.database.Cursor query(@android.support.annotation.NonNull\r\nandroid.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder) {\r\n    java.lang.String[] columnNames = (projection == null) ? com.fsck.k9.provider.AttachmentProvider.DEFAULT_PROJECTION : projection;\r\n    java.util.List<java.lang.String> segments = uri.getPathSegments();\r\n    java.lang.String accountUuid = segments.get(0);\r\n    java.lang.String id = segments.get(1);\r\n    final com.fsck.k9.mailstore.LocalStore.AttachmentInfo attachmentInfo;\r\n    try {\r\n        final com.fsck.k9.Account account = com.fsck.k9.Preferences.getPreferences(getContext()).getAccount(accountUuid);\r\n        attachmentInfo = com.fsck.k9.mailstore.LocalStore.getInstance(account, getContext()).getAttachmentInfo(id);\r\n    } catch (com.fsck.k9.mail.MessagingException e) {\r\n        timber.log.Timber.e(e, \"Unable to retrieve attachment info from local store for ID: %s\", id);\r\n        return null;\r\n    }\r\n    if (attachmentInfo == null) {\r\n        timber.log.Timber.d(\"No attachment info for ID: %s\", id);\r\n        return null;\r\n    }\r\n    android.database.MatrixCursor ret = new android.database.MatrixCursor(columnNames);\r\n    java.lang.Object[] values = new java.lang.Object[columnNames.length];\r\n    for (int i = 0, count = columnNames.length; i < count; i++) {\r\n        java.lang.String column = columnNames[i];\r\n        if (com.fsck.k9.provider.AttachmentProvider.AttachmentProviderColumns._ID.equals(column)) {\r\n            values[i] = id;\r\n        } else if (com.fsck.k9.provider.AttachmentProvider.AttachmentProviderColumns.DATA.equals(column)) {\r\n            values[i] = uri.toString();\r\n        } else if (com.fsck.k9.provider.AttachmentProvider.AttachmentProviderColumns.DISPLAY_NAME.equals(column)) {\r\n            values[i] = attachmentInfo.name;\r\n        } else if (com.fsck.k9.provider.AttachmentProvider.AttachmentProviderColumns.SIZE.equals(column)) {\r\n            values[i] = attachmentInfo.size;\r\n        }\r\n    }\r\n    ret.addRow(values);\r\n    return ret;\r\n}",
        "name": "query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "openFile(android.net.Uri,java.lang.String)",
        "qualifiedName": "com.fsck.k9.provider.AttachmentProvider.openFile(android.net.Uri,java.lang.String)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic android.os.ParcelFileDescriptor openFile(@android.support.annotation.NonNull\r\nandroid.net.Uri uri, @android.support.annotation.NonNull\r\njava.lang.String mode) throws java.io.FileNotFoundException {\r\n    java.util.List<java.lang.String> segments = uri.getPathSegments();\r\n    java.lang.String accountUuid = segments.get(0);\r\n    java.lang.String attachmentId = segments.get(1);\r\n    android.os.ParcelFileDescriptor parcelFileDescriptor = openAttachment(accountUuid, attachmentId);\r\n    if (parcelFileDescriptor == null) {\r\n        throw new java.io.FileNotFoundException(\"Attachment missing or cannot be opened!\");\r\n    }\r\n    return parcelFileDescriptor;\r\n}",
        "name": "openFile(android.net.Uri,java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getType(android.net.Uri)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.provider.AttachmentProvider.getType(android.net.Uri)",
        "sourceText": "@java.lang.Override\r\npublic java.lang.String getType(@android.support.annotation.NonNull\r\nandroid.net.Uri uri) {\r\n    java.util.List<java.lang.String> segments = uri.getPathSegments();\r\n    java.lang.String accountUuid = segments.get(0);\r\n    java.lang.String id = segments.get(1);\r\n    java.lang.String mimeType = (segments.size() < 3) ? null : segments.get(2);\r\n    return getType(accountUuid, id, mimeType);\r\n}",
        "name": "getType(android.net.Uri)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.provider.AttachmentTempFileProvider": [
      {
        "visibility": "public",
        "simpleName": "deleteOldTemporaryFiles(android.content.Context)",
        "qualifiedName": "com.fsck.k9.provider.AttachmentTempFileProvider.deleteOldTemporaryFiles(android.content.Context)",
        "kind": "method",
        "sourceText": "public static boolean deleteOldTemporaryFiles(android.content.Context context) {\r\n    java.io.File tempDirectory = com.fsck.k9.provider.AttachmentTempFileProvider.getTempFileDirectory(context);\r\n    boolean allFilesDeleted = true;\r\n    long deletionThreshold = java.lang.System.currentTimeMillis() - com.fsck.k9.provider.AttachmentTempFileProvider.FILE_DELETE_THRESHOLD_MILLISECONDS;\r\n    for (java.io.File tempFile : tempDirectory.listFiles()) {\r\n        long lastModified = tempFile.lastModified();\r\n        if (lastModified < deletionThreshold) {\r\n            boolean fileDeleted = tempFile.delete();\r\n            if (!fileDeleted) {\r\n                timber.log.Timber.e(\"Failed to delete temporary file\");\r\n                // TODO really do this? might cause our service to stay up indefinitely if a file can't be deleted\r\n                allFilesDeleted = false;\r\n            }\r\n        } else {\r\n            if (com.fsck.k9.K9.isDebug()) {\r\n                java.lang.String timeLeftStr = java.lang.String.format(java.util.Locale.ENGLISH, \"%.2f\", ((lastModified - deletionThreshold) / 1000) / 60.0);\r\n                timber.log.Timber.e(\"Not deleting temp file (for another %s minutes)\", timeLeftStr);\r\n            }\r\n            allFilesDeleted = false;\r\n        }\r\n    }\r\n    return allFilesDeleted;\r\n}",
        "name": "deleteOldTemporaryFiles(android.content.Context)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onTrimMemory(int)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.provider.AttachmentTempFileProvider.onTrimMemory(int)",
        "sourceText": "@java.lang.Override\r\npublic void onTrimMemory(int level) {\r\n    if (level < TRIM_MEMORY_COMPLETE) {\r\n        return;\r\n    }\r\n    final android.content.Context context = getContext();\r\n    if (context == null) {\r\n        return;\r\n    }\r\n    new android.os.AsyncTask<java.lang.Void, java.lang.Void, java.lang.Void>() {\r\n        @java.lang.Override\r\n        protected java.lang.Void doInBackground(java.lang.Void... voids) {\r\n            com.fsck.k9.provider.AttachmentTempFileProvider.deleteOldTemporaryFiles(context);\r\n            return null;\r\n        }\r\n    }.execute();\r\n    com.fsck.k9.provider.AttachmentTempFileProvider.unregisterFileCleanupReceiver(context);\r\n}",
        "name": "onTrimMemory(int)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getMimeTypeUri(android.net.Uri,java.lang.String)",
        "qualifiedName": "com.fsck.k9.provider.AttachmentTempFileProvider.getMimeTypeUri(android.net.Uri,java.lang.String)",
        "kind": "method",
        "sourceText": "public static android.net.Uri getMimeTypeUri(android.net.Uri contentUri, java.lang.String mimeType) {\r\n    if (!com.fsck.k9.provider.AttachmentTempFileProvider.AUTHORITY.equals(contentUri.getAuthority())) {\r\n        throw new java.lang.IllegalArgumentException(\"Can only call this method for URIs within this authority!\");\r\n    }\r\n    if (contentUri.getQueryParameter(\"mime_type\") != null) {\r\n        throw new java.lang.IllegalArgumentException(\"Can only call this method for not yet typed URIs!\");\r\n    }\r\n    return contentUri.buildUpon().appendQueryParameter(\"mime_type\", mimeType).build();\r\n}",
        "name": "getMimeTypeUri(android.net.Uri,java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "createTempUriForContentUri(android.content.Context,android.net.Uri)",
        "qualifiedName": "com.fsck.k9.provider.AttachmentTempFileProvider.createTempUriForContentUri(android.content.Context,android.net.Uri)",
        "kind": "method",
        "sourceText": "@android.support.annotation.WorkerThread\r\npublic static android.net.Uri createTempUriForContentUri(android.content.Context context, android.net.Uri uri) throws java.io.IOException {\r\n    android.content.Context applicationContext = context.getApplicationContext();\r\n    java.io.File tempFile = com.fsck.k9.provider.AttachmentTempFileProvider.getTempFileForUri(uri, applicationContext);\r\n    com.fsck.k9.provider.AttachmentTempFileProvider.writeUriContentToTempFileIfNotExists(context, uri, tempFile);\r\n    android.net.Uri tempFileUri = android.support.v4.content.FileProvider.getUriForFile(context, com.fsck.k9.provider.AttachmentTempFileProvider.AUTHORITY, tempFile);\r\n    com.fsck.k9.provider.AttachmentTempFileProvider.registerFileCleanupReceiver(applicationContext);\r\n    return tempFileUri;\r\n}",
        "name": "createTempUriForContentUri(android.content.Context,android.net.Uri)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.remotecontrol": {
    "com.fsck.k9.remotecontrol.AccountReceiver": [
      {
        "visibility": "public",
        "simpleName": "onReceive(android.content.Context,android.content.Intent)",
        "qualifiedName": "com.fsck.k9.remotecontrol.AccountReceiver.onReceive(android.content.Context,android.content.Intent)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic void onReceive(android.content.Context context, android.content.Intent intent) {\r\n    if (com.fsck.k9.remotecontrol.K9RemoteControl.K9_REQUEST_ACCOUNTS.equals(intent.getAction())) {\r\n        android.os.Bundle bundle = getResultExtras(false);\r\n        if (bundle == null) {\r\n            timber.log.Timber.w(\"Response bundle is empty\");\r\n            return;\r\n        }\r\n        receptor.accounts(bundle.getStringArray(com.fsck.k9.remotecontrol.K9RemoteControl.K9_ACCOUNT_UUIDS), bundle.getStringArray(com.fsck.k9.remotecontrol.K9RemoteControl.K9_ACCOUNT_DESCRIPTIONS));\r\n    }\r\n}",
        "name": "onReceive(android.content.Context,android.content.Intent)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.remotecontrol.K9RemoteControl": [
      {
        "visibility": "public",
        "simpleName": "fetchAccounts(android.content.Context,com.fsck.k9.remotecontrol.K9AccountReceptor)",
        "qualifiedName": "com.fsck.k9.remotecontrol.K9RemoteControl.fetchAccounts(android.content.Context,com.fsck.k9.remotecontrol.K9AccountReceptor)",
        "kind": "method",
        "sourceText": "public static void fetchAccounts(android.content.Context context, com.fsck.k9.remotecontrol.K9AccountReceptor receptor) {\r\n    android.content.Intent accountFetchIntent = new android.content.Intent();\r\n    accountFetchIntent.setAction(com.fsck.k9.remotecontrol.K9RemoteControl.K9_REQUEST_ACCOUNTS);\r\n    com.fsck.k9.remotecontrol.AccountReceiver receiver = new com.fsck.k9.remotecontrol.AccountReceiver(receptor);\r\n    context.sendOrderedBroadcast(accountFetchIntent, com.fsck.k9.remotecontrol.K9RemoteControl.K9_REMOTE_CONTROL_PERMISSION, receiver, null, Activity.RESULT_OK, null, null);\r\n}",
        "name": "fetchAccounts(android.content.Context,com.fsck.k9.remotecontrol.K9AccountReceptor)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.remotecontrol.K9AccountReceptor": []
  },
  "com.fsck.k9.search": {
    "com.fsck.k9.search.ConditionsTreeNode": [
      {
        "visibility": "public",
        "simpleName": "and(com.fsck.k9.search.SearchSpecification$SearchCondition)",
        "qualifiedName": "com.fsck.k9.search.ConditionsTreeNode.and(com.fsck.k9.search.SearchSpecification$SearchCondition)",
        "kind": "method",
        "sourceText": "/**\r\n * Convenience method.\r\n * Adds the provided condition as the second argument of an AND\r\n * clause to this node.\r\n *\r\n * @param condition\r\n * \t\tCondition to 'AND' with.\r\n * @return New top AND node, new root.\r\n */\r\npublic com.fsck.k9.search.ConditionsTreeNode and(com.fsck.k9.search.SearchSpecification.SearchCondition condition) {\r\n    try {\r\n        com.fsck.k9.search.ConditionsTreeNode tmp = new com.fsck.k9.search.ConditionsTreeNode(condition);\r\n        return and(tmp);\r\n    } catch (java.lang.Exception e) {\r\n        // impossible\r\n        return null;\r\n    }\r\n}",
        "name": "and(com.fsck.k9.search.SearchSpecification$SearchCondition)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getLeafSet()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.search.ConditionsTreeNode.getLeafSet()",
        "sourceText": "/**\r\n * Get a set of all the leaves in the tree.\r\n *\r\n * @return Set of all the leaves.\r\n */\r\npublic java.util.Set<com.fsck.k9.search.ConditionsTreeNode> getLeafSet() {\r\n    java.util.Set<com.fsck.k9.search.ConditionsTreeNode> leafSet = new java.util.HashSet<com.fsck.k9.search.ConditionsTreeNode>();\r\n    return getLeafSet(leafSet);\r\n}",
        "name": "getLeafSet()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "or(com.fsck.k9.search.ConditionsTreeNode)",
        "qualifiedName": "com.fsck.k9.search.ConditionsTreeNode.or(com.fsck.k9.search.ConditionsTreeNode)",
        "kind": "method",
        "sourceText": "/**\r\n * Adds the expression as the second argument of an OR\r\n * clause to this node.\r\n *\r\n * @param expr\r\n * \t\tExpression to 'OR' with.\r\n * @return New top OR node.\r\n * @throws Exception\r\n */\r\npublic com.fsck.k9.search.ConditionsTreeNode or(com.fsck.k9.search.ConditionsTreeNode expr) throws java.lang.Exception {\r\n    return add(expr, com.fsck.k9.search.ConditionsTreeNode.Operator.OR);\r\n}",
        "name": "or(com.fsck.k9.search.ConditionsTreeNode)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "or(com.fsck.k9.search.SearchSpecification$SearchCondition)",
        "qualifiedName": "com.fsck.k9.search.ConditionsTreeNode.or(com.fsck.k9.search.SearchSpecification$SearchCondition)",
        "kind": "method",
        "sourceText": "/**\r\n * Convenience method.\r\n * Adds the provided condition as the second argument of an OR\r\n * clause to this node.\r\n *\r\n * @param condition\r\n * \t\tCondition to 'OR' with.\r\n * @return New top OR node, new root.\r\n */\r\npublic com.fsck.k9.search.ConditionsTreeNode or(com.fsck.k9.search.SearchSpecification.SearchCondition condition) {\r\n    try {\r\n        com.fsck.k9.search.ConditionsTreeNode tmp = new com.fsck.k9.search.ConditionsTreeNode(condition);\r\n        return or(tmp);\r\n    } catch (java.lang.Exception e) {\r\n        // impossible\r\n        return null;\r\n    }\r\n}",
        "name": "or(com.fsck.k9.search.SearchSpecification$SearchCondition)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getCondition()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.search.ConditionsTreeNode.getCondition()",
        "sourceText": "// ///////////////////////////////////////////////////////////\r\n// Public accessors\r\n// ///////////////////////////////////////////////////////////\r\n/**\r\n * Returns the condition stored in this node.\r\n *\r\n * @return Condition stored in the node.\r\n */\r\npublic com.fsck.k9.search.SearchSpecification.SearchCondition getCondition() {\r\n    return mCondition;\r\n}",
        "name": "getCondition()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "preorder()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.search.ConditionsTreeNode.preorder()",
        "sourceText": "/**\r\n * Returns a list of all the nodes in the subtree of which this node\r\n * is the root. The list contains the nodes in a pre traversal order.\r\n *\r\n * @return List of all nodes in subtree in preorder.\r\n */\r\npublic java.util.List<com.fsck.k9.search.ConditionsTreeNode> preorder() {\r\n    java.util.List<com.fsck.k9.search.ConditionsTreeNode> result = new java.util.ArrayList<com.fsck.k9.search.ConditionsTreeNode>();\r\n    java.util.Stack<com.fsck.k9.search.ConditionsTreeNode> stack = new java.util.Stack<com.fsck.k9.search.ConditionsTreeNode>();\r\n    stack.push(this);\r\n    while (!stack.isEmpty()) {\r\n        com.fsck.k9.search.ConditionsTreeNode current = stack.pop();\r\n        if (current.mLeft != null) {\r\n            stack.push(current.mLeft);\r\n        }\r\n        if (current.mRight != null) {\r\n            stack.push(current.mRight);\r\n        }\r\n        result.add(current);\r\n    } \r\n    return result;\r\n}",
        "name": "preorder()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "and(com.fsck.k9.search.ConditionsTreeNode)",
        "qualifiedName": "com.fsck.k9.search.ConditionsTreeNode.and(com.fsck.k9.search.ConditionsTreeNode)",
        "kind": "method",
        "sourceText": "// ///////////////////////////////////////////////////////////\r\n// Public modifiers\r\n// ///////////////////////////////////////////////////////////\r\n/**\r\n * Adds the expression as the second argument of an AND\r\n * clause to this node.\r\n *\r\n * @param expr\r\n * \t\tExpression to 'AND' with.\r\n * @return New top AND node.\r\n * @throws Exception\r\n */\r\npublic com.fsck.k9.search.ConditionsTreeNode and(com.fsck.k9.search.ConditionsTreeNode expr) throws java.lang.Exception {\r\n    return add(expr, com.fsck.k9.search.ConditionsTreeNode.Operator.AND);\r\n}",
        "name": "and(com.fsck.k9.search.ConditionsTreeNode)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "buildTreeFromDB(android.database.Cursor)",
        "qualifiedName": "com.fsck.k9.search.ConditionsTreeNode.buildTreeFromDB(android.database.Cursor)",
        "kind": "method",
        "sourceText": "// ///////////////////////////////////////////////////////////\r\n// Static Helpers to restore a tree from a database cursor\r\n// ///////////////////////////////////////////////////////////\r\n/**\r\n * Builds a condition tree starting from a database cursor. The cursor\r\n * should point to rows representing the nodes of the tree.\r\n *\r\n * @param cursor\r\n * \t\tCursor pointing to the first of a bunch or rows. Each rows\r\n * \t\tshould contains 1 tree node.\r\n * @return A condition tree.\r\n */\r\npublic static com.fsck.k9.search.ConditionsTreeNode buildTreeFromDB(android.database.Cursor cursor) {\r\n    java.util.Stack<com.fsck.k9.search.ConditionsTreeNode> stack = new java.util.Stack<com.fsck.k9.search.ConditionsTreeNode>();\r\n    com.fsck.k9.search.ConditionsTreeNode tmp = null;\r\n    // root node\r\n    if (cursor.moveToFirst()) {\r\n        tmp = com.fsck.k9.search.ConditionsTreeNode.buildNodeFromRow(cursor);\r\n        stack.push(tmp);\r\n    }\r\n    // other nodes\r\n    while (cursor.moveToNext()) {\r\n        tmp = com.fsck.k9.search.ConditionsTreeNode.buildNodeFromRow(cursor);\r\n        if (tmp.mRightMPTTMarker < stack.peek().mRightMPTTMarker) {\r\n            stack.peek().mLeft = tmp;\r\n            stack.push(tmp);\r\n        } else {\r\n            while (stack.peek().mRightMPTTMarker < tmp.mRightMPTTMarker) {\r\n                stack.pop();\r\n            } \r\n            stack.peek().mRight = tmp;\r\n        }\r\n    } \r\n    return tmp;\r\n}",
        "name": "buildTreeFromDB(android.database.Cursor)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "describeContents()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.search.ConditionsTreeNode.describeContents()",
        "sourceText": "// ///////////////////////////////////////////////////////////\r\n// Parcelable\r\n// \r\n// This whole class has to be parcelable because it's passed\r\n// on through intents.\r\n// ///////////////////////////////////////////////////////////\r\n@java.lang.Override\r\npublic int describeContents() {\r\n    return 0;\r\n}",
        "name": "describeContents()",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.search.SearchAccount": [
      {
        "visibility": "public",
        "simpleName": "createAllMessagesAccount(android.content.Context)",
        "qualifiedName": "com.fsck.k9.search.SearchAccount.createAllMessagesAccount(android.content.Context)",
        "kind": "method",
        "sourceText": "// create the all messages search ( all accounts is default when none specified )\r\npublic static com.fsck.k9.search.SearchAccount createAllMessagesAccount(android.content.Context context) {\r\n    java.lang.String name = context.getString(R.string.search_all_messages_title);\r\n    com.fsck.k9.search.LocalSearch tmpSearch = new com.fsck.k9.search.LocalSearch(name);\r\n    tmpSearch.and(com.fsck.k9.search.SearchSpecification.SearchField.SEARCHABLE, \"1\", com.fsck.k9.search.SearchSpecification.Attribute.EQUALS);\r\n    return new com.fsck.k9.search.SearchAccount(com.fsck.k9.search.SearchAccount.ALL_MESSAGES, tmpSearch, name, context.getString(R.string.search_all_messages_detail));\r\n}",
        "name": "createAllMessagesAccount(android.content.Context)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "createUnifiedInboxAccount(android.content.Context)",
        "qualifiedName": "com.fsck.k9.search.SearchAccount.createUnifiedInboxAccount(android.content.Context)",
        "kind": "method",
        "sourceText": "// create the unified inbox meta account ( all accounts is default when none specified )\r\npublic static com.fsck.k9.search.SearchAccount createUnifiedInboxAccount(android.content.Context context) {\r\n    java.lang.String name = context.getString(R.string.integrated_inbox_title);\r\n    com.fsck.k9.search.LocalSearch tmpSearch = new com.fsck.k9.search.LocalSearch(name);\r\n    tmpSearch.and(com.fsck.k9.search.SearchSpecification.SearchField.INTEGRATE, \"1\", com.fsck.k9.search.SearchSpecification.Attribute.EQUALS);\r\n    return new com.fsck.k9.search.SearchAccount(com.fsck.k9.search.SearchAccount.UNIFIED_INBOX, tmpSearch, name, context.getString(R.string.integrated_inbox_detail));\r\n}",
        "name": "createUnifiedInboxAccount(android.content.Context)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getUuid()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.search.SearchAccount.getUuid()",
        "sourceText": "/**\r\n * Returns the ID of this {@code SearchAccount} instance.\r\n *\r\n * <p>\r\n * This isn't really a UUID. But since we don't expose this value to other apps and we only\r\n * use the account UUID as opaque string (e.g. as key in a {@code Map}) we're fine.<br>\r\n * Using a constant string is necessary to identify the same search account even when the\r\n * corresponding {@link SearchAccount} object has been recreated.\r\n * </p>\r\n */\r\n@java.lang.Override\r\npublic java.lang.String getUuid() {\r\n    return mId;\r\n}",
        "name": "getUuid()",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.search.LocalSearch": [
      {
        "visibility": "public",
        "simpleName": "setName(java.lang.String)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.search.LocalSearch.setName(java.lang.String)",
        "sourceText": "// ///////////////////////////////////////////////////////////\r\n// Public manipulation methods\r\n// ///////////////////////////////////////////////////////////\r\n/**\r\n * Sets the name of the saved search. If one existed it will\r\n * be overwritten.\r\n *\r\n * @param name\r\n * \t\tName to be set.\r\n */\r\npublic void setName(java.lang.String name) {\r\n    this.mName = name;\r\n}",
        "name": "setName(java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "addAllowedFolder(java.lang.String)",
        "qualifiedName": "com.fsck.k9.search.LocalSearch.addAllowedFolder(java.lang.String)",
        "kind": "method",
        "sourceText": "/**\r\n * TODO\r\n * FOR NOW: And the folder with the root.\r\n *\r\n * Add the folder as another folder to search in. The folder\r\n * will be added AND to the root if no 'folder subtree' was found.\r\n * Otherwise the folder will be added OR to that tree.\r\n *\r\n * @param name\r\n * \t\tName of the folder to add.\r\n */\r\npublic void addAllowedFolder(java.lang.String name) {\r\n    /* TODO find folder sub-tree\n    - do and on root of it & rest of search\n    - do or between folder nodes\n     */\r\n    mConditions = and(new com.fsck.k9.search.SearchSpecification.SearchCondition(com.fsck.k9.search.SearchSpecification.SearchField.FOLDER, com.fsck.k9.search.SearchSpecification.Attribute.EQUALS, name));\r\n}",
        "name": "addAllowedFolder(java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "and(com.fsck.k9.search.SearchSpecification$SearchField,java.lang.String,com.fsck.k9.search.SearchSpecification$Attribute)",
        "qualifiedName": "com.fsck.k9.search.LocalSearch.and(com.fsck.k9.search.SearchSpecification$SearchField,java.lang.String,com.fsck.k9.search.SearchSpecification$Attribute)",
        "kind": "method",
        "sourceText": "/**\r\n * Adds the provided node as the second argument of an AND\r\n * clause to this node.\r\n *\r\n * @param field\r\n * \t\tMessage table field to match against.\r\n * @param value\r\n * \t\tValue to look for.\r\n * @param attribute\r\n * \t\tAttribute to use when matching.\r\n */\r\npublic void and(com.fsck.k9.search.SearchSpecification.SearchField field, java.lang.String value, com.fsck.k9.search.SearchSpecification.Attribute attribute) {\r\n    and(new com.fsck.k9.search.SearchSpecification.SearchCondition(field, attribute, value));\r\n}",
        "name": "and(com.fsck.k9.search.SearchSpecification$SearchField,java.lang.String,com.fsck.k9.search.SearchSpecification$Attribute)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "and(com.fsck.k9.search.SearchSpecification$SearchCondition)",
        "qualifiedName": "com.fsck.k9.search.LocalSearch.and(com.fsck.k9.search.SearchSpecification$SearchCondition)",
        "kind": "method",
        "sourceText": "/**\r\n * Adds the provided condition as the second argument of an AND\r\n * clause to this node.\r\n *\r\n * @param condition\r\n * \t\tCondition to 'AND' with.\r\n * @return New top AND node, new root.\r\n */\r\npublic com.fsck.k9.search.ConditionsTreeNode and(com.fsck.k9.search.SearchSpecification.SearchCondition condition) {\r\n    try {\r\n        com.fsck.k9.search.ConditionsTreeNode tmp = new com.fsck.k9.search.ConditionsTreeNode(condition);\r\n        return and(tmp);\r\n    } catch (java.lang.Exception e) {\r\n        // impossible\r\n        return null;\r\n    }\r\n}",
        "name": "and(com.fsck.k9.search.SearchSpecification$SearchCondition)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "or(com.fsck.k9.search.ConditionsTreeNode)",
        "qualifiedName": "com.fsck.k9.search.LocalSearch.or(com.fsck.k9.search.ConditionsTreeNode)",
        "kind": "method",
        "sourceText": "/**\r\n * Adds the provided node as the second argument of an OR\r\n * clause to this node.\r\n *\r\n * @param node\r\n * \t\tNode to 'OR' with.\r\n * @return New top OR node, new root.\r\n * @throws Exception\r\n */\r\npublic com.fsck.k9.search.ConditionsTreeNode or(com.fsck.k9.search.ConditionsTreeNode node) throws java.lang.Exception {\r\n    mLeafSet.addAll(node.getLeafSet());\r\n    if (mConditions == null) {\r\n        mConditions = node;\r\n        return node;\r\n    }\r\n    mConditions = mConditions.or(node);\r\n    return mConditions;\r\n}",
        "name": "or(com.fsck.k9.search.ConditionsTreeNode)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getRemoteSearchArguments()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.search.LocalSearch.getRemoteSearchArguments()",
        "sourceText": "// ///////////////////////////////////////////////////////////\r\n// Public accesor methods\r\n// ///////////////////////////////////////////////////////////\r\n/**\r\n * TODO THIS HAS TO GO!!!!\r\n * very dirty fix for remotesearch support atm\r\n */\r\npublic java.lang.String getRemoteSearchArguments() {\r\n    java.util.Set<com.fsck.k9.search.ConditionsTreeNode> leafSet = getLeafSet();\r\n    if (leafSet == null) {\r\n        return null;\r\n    }\r\n    for (com.fsck.k9.search.ConditionsTreeNode node : leafSet) {\r\n        if ((node.getCondition().field == com.fsck.k9.search.SearchSpecification.SearchField.SUBJECT) || (node.getCondition().field == com.fsck.k9.search.SearchSpecification.SearchField.SENDER)) {\r\n            return node.getCondition().value;\r\n        }\r\n    }\r\n    return null;\r\n}",
        "name": "getRemoteSearchArguments()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "addAccountUuid(java.lang.String)",
        "qualifiedName": "com.fsck.k9.search.LocalSearch.addAccountUuid(java.lang.String)",
        "kind": "method",
        "sourceText": "/**\r\n * Add a new account to the search. When no accounts are\r\n * added manually we search all accounts on the device.\r\n *\r\n * @param uuid\r\n * \t\tUuid of the account to be added.\r\n */\r\npublic void addAccountUuid(java.lang.String uuid) {\r\n    if (uuid.equals(com.fsck.k9.search.SearchSpecification.ALL_ACCOUNTS)) {\r\n        mAccountUuids.clear();\r\n        return;\r\n    }\r\n    mAccountUuids.add(uuid);\r\n}",
        "name": "addAccountUuid(java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getFolderNames()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.search.LocalSearch.getFolderNames()",
        "sourceText": "/* TODO make this more advanced!\nThis is a temporarely solution that does NOT WORK for\nreal searches because of possible extra conditions to a folder requirement.\n */\r\npublic java.util.List<java.lang.String> getFolderNames() {\r\n    java.util.List<java.lang.String> results = new java.util.ArrayList<java.lang.String>();\r\n    for (com.fsck.k9.search.ConditionsTreeNode node : mLeafSet) {\r\n        if ((node.mCondition.field == com.fsck.k9.search.SearchSpecification.SearchField.FOLDER) && (node.mCondition.attribute == com.fsck.k9.search.SearchSpecification.Attribute.EQUALS)) {\r\n            results.add(node.mCondition.value);\r\n        }\r\n    }\r\n    return results;\r\n}",
        "name": "getFolderNames()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "or(com.fsck.k9.search.SearchSpecification$SearchCondition)",
        "qualifiedName": "com.fsck.k9.search.LocalSearch.or(com.fsck.k9.search.SearchSpecification$SearchCondition)",
        "kind": "method",
        "sourceText": "/**\r\n * Adds the provided condition as the second argument of an OR\r\n * clause to this node.\r\n *\r\n * @param condition\r\n * \t\tCondition to 'OR' with.\r\n * @return New top OR node, new root.\r\n */\r\npublic com.fsck.k9.search.ConditionsTreeNode or(com.fsck.k9.search.SearchSpecification.SearchCondition condition) {\r\n    try {\r\n        com.fsck.k9.search.ConditionsTreeNode tmp = new com.fsck.k9.search.ConditionsTreeNode(condition);\r\n        return or(tmp);\r\n    } catch (java.lang.Exception e) {\r\n        // impossible\r\n        return null;\r\n    }\r\n}",
        "name": "or(com.fsck.k9.search.SearchSpecification$SearchCondition)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "clone()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.search.LocalSearch.clone()",
        "sourceText": "@java.lang.Override\r\npublic com.fsck.k9.search.LocalSearch clone() {\r\n    com.fsck.k9.search.ConditionsTreeNode conditions = (mConditions == null) ? null : mConditions.cloneTree();\r\n    com.fsck.k9.search.LocalSearch copy = new com.fsck.k9.search.LocalSearch(mName, conditions, null, mPredefined);\r\n    copy.mManualSearch = mManualSearch;\r\n    copy.mAccountUuids = new java.util.HashSet<java.lang.String>(mAccountUuids);\r\n    return copy;\r\n}",
        "name": "clone()",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.service": {
    "com.fsck.k9.service.BootReceiver": [
      {
        "visibility": "public",
        "simpleName": "scheduleIntent(android.content.Context,long,android.content.Intent)",
        "qualifiedName": "com.fsck.k9.service.BootReceiver.scheduleIntent(android.content.Context,long,android.content.Intent)",
        "kind": "method",
        "sourceText": "public static void scheduleIntent(android.content.Context context, long atTime, android.content.Intent alarmedIntent) {\r\n    timber.log.Timber.i(\"BootReceiver Got request to schedule alarmedIntent %s\", alarmedIntent.getAction());\r\n    android.content.Intent i = new android.content.Intent();\r\n    i.setClass(context, com.fsck.k9.service.BootReceiver.class);\r\n    i.setAction(com.fsck.k9.service.BootReceiver.SCHEDULE_INTENT);\r\n    i.putExtra(com.fsck.k9.service.BootReceiver.ALARMED_INTENT, alarmedIntent);\r\n    i.putExtra(com.fsck.k9.service.BootReceiver.AT_TIME, atTime);\r\n    context.sendBroadcast(i);\r\n}",
        "name": "scheduleIntent(android.content.Context,long,android.content.Intent)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "cancelIntent(android.content.Context,android.content.Intent)",
        "qualifiedName": "com.fsck.k9.service.BootReceiver.cancelIntent(android.content.Context,android.content.Intent)",
        "kind": "method",
        "sourceText": "public static void cancelIntent(android.content.Context context, android.content.Intent alarmedIntent) {\r\n    timber.log.Timber.i(\"BootReceiver Got request to cancel alarmedIntent %s\", alarmedIntent.getAction());\r\n    android.content.Intent i = new android.content.Intent();\r\n    i.setClass(context, com.fsck.k9.service.BootReceiver.class);\r\n    i.setAction(com.fsck.k9.service.BootReceiver.CANCEL_INTENT);\r\n    i.putExtra(com.fsck.k9.service.BootReceiver.ALARMED_INTENT, alarmedIntent);\r\n    context.sendBroadcast(i);\r\n}",
        "name": "cancelIntent(android.content.Context,android.content.Intent)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "purgeSchedule(android.content.Context)",
        "qualifiedName": "com.fsck.k9.service.BootReceiver.purgeSchedule(android.content.Context)",
        "kind": "method",
        "sourceText": "/**\r\n * Cancel any scheduled alarm.\r\n *\r\n * @param context\r\n */\r\npublic static void purgeSchedule(final android.content.Context context) {\r\n    final com.fsck.k9.helper.K9AlarmManager alarmService = com.fsck.k9.helper.K9AlarmManager.getAlarmManager(context);\r\n    alarmService.cancel(android.app.PendingIntent.getBroadcast(context, 0, new android.content.Intent() {\r\n        @java.lang.Override\r\n        public boolean filterEquals(final android.content.Intent other) {\r\n            // we want to match all intents\r\n            return true;\r\n        }\r\n    }, 0));\r\n}",
        "name": "purgeSchedule(android.content.Context)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.service.CoreService": [
      {
        "visibility": "public",
        "simpleName": "onStartCommand(android.content.Intent,int,int)",
        "qualifiedName": "com.fsck.k9.service.CoreService.onStartCommand(android.content.Intent,int,int)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic final int onStartCommand(android.content.Intent intent, int flags, int startId) {\r\n    /* When a process is killed due to low memory, it's later restarted and services that were\n    started with START_STICKY are started with the intent being null.\n\n    For now we just ignore these restart events. This should be fine because all necessary\n    services are started from K9.onCreate() when the Application object is initialized.\n\n    See issue 3750\n     */\r\n    if (intent == null) {\r\n        stopSelf(startId);\r\n        return START_NOT_STICKY;\r\n    }\r\n    // Acquire new wake lock\r\n    com.fsck.k9.mail.power.TracingPowerManager.TracingWakeLock wakeLock = com.fsck.k9.service.CoreService.acquireWakeLock(this, \"CoreService onStart\", com.fsck.k9.K9.MAIL_SERVICE_WAKE_LOCK_TIMEOUT);\r\n    timber.log.Timber.i(\"CoreService: %s.onStart(%s, %d)\", className, intent, startId);\r\n    // If we were started by BootReceiver, release the wake lock acquired there.\r\n    int wakeLockId = intent.getIntExtra(com.fsck.k9.service.BootReceiver.WAKE_LOCK_ID, -1);\r\n    if (wakeLockId != (-1)) {\r\n        com.fsck.k9.service.BootReceiver.releaseWakeLock(this, wakeLockId);\r\n    }\r\n    // If we were passed an ID from our own wake lock registry, retrieve that wake lock and\r\n    // release it.\r\n    int coreWakeLockId = intent.getIntExtra(com.fsck.k9.service.CoreService.WAKE_LOCK_ID, -1);\r\n    if (coreWakeLockId != (-1)) {\r\n        timber.log.Timber.d(\"Got core wake lock id %d\", coreWakeLockId);\r\n        // Remove wake lock from the registry\r\n        com.fsck.k9.mail.power.TracingPowerManager.TracingWakeLock coreWakeLock = com.fsck.k9.service.CoreService.sWakeLocks.remove(coreWakeLockId);\r\n        // Release wake lock\r\n        if (coreWakeLock != null) {\r\n            timber.log.Timber.d(\"Found core wake lock with id %d, releasing\", coreWakeLockId);\r\n            coreWakeLock.release();\r\n        }\r\n    }\r\n    // Run the actual start-code of the service\r\n    mImmediateShutdown = true;\r\n    int startFlag;\r\n    try {\r\n        startFlag = startService(intent, startId);\r\n    } finally {\r\n        try {\r\n            // Release the wake lock acquired at the start of this method\r\n            wakeLock.release();\r\n        } catch (java.lang.Exception e) {\r\n            /* ignore */\r\n        }\r\n        try {\r\n            // If there is no outstanding work to be done in a background thread we can stop\r\n            // this service.\r\n            if ((mAutoShutdown && mImmediateShutdown) && (startId != (-1))) {\r\n                stopSelf(startId);\r\n                startFlag = START_NOT_STICKY;\r\n            }\r\n        } catch (java.lang.Exception e) {\r\n            /* ignore */\r\n        }\r\n    }\r\n    return startFlag;\r\n}",
        "name": "onStartCommand(android.content.Intent,int,int)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "startService(android.content.Intent,int)",
        "qualifiedName": "com.fsck.k9.service.CoreService.startService(android.content.Intent,int)",
        "kind": "method",
        "sourceText": "/**\r\n * Subclasses need to implement this instead of overriding {@link #onStartCommand(Intent, int, int)}.\r\n *\r\n * <p>\r\n * This allows {@link CoreService} to manage the service lifecycle, incl. wake lock management.\r\n * </p>\r\n *\r\n * @param intent\r\n * \t\tThe Intent supplied to {@link Context#startService(Intent)}.\r\n * @param startId\r\n * \t\tA unique integer representing this specific request to start. Use with\r\n * \t\t{@link #stopSelfResult(int)}.\r\n * @return The return value indicates what semantics the system should use for the service's\r\ncurrent started state. It may be one of the constants associated with the\r\n{@link Service#START_CONTINUATION_MASK} bits.\r\n */\r\npublic abstract int startService(android.content.Intent intent, int startId);",
        "name": "startService(android.content.Intent,int)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.service.RemoteControlService": [
      {
        "visibility": "public",
        "simpleName": "set(android.content.Context,android.content.Intent,java.lang.Integer)",
        "qualifiedName": "com.fsck.k9.service.RemoteControlService.set(android.content.Context,android.content.Intent,java.lang.Integer)",
        "kind": "method",
        "sourceText": "public static void set(android.content.Context context, android.content.Intent i, java.lang.Integer wakeLockId) {\r\n    // Intent i = new Intent();\r\n    i.setClass(context, com.fsck.k9.service.RemoteControlService.class);\r\n    i.setAction(com.fsck.k9.service.RemoteControlService.SET_ACTION);\r\n    com.fsck.k9.service.CoreService.addWakeLockId(context, i, wakeLockId, true);\r\n    context.startService(i);\r\n}",
        "name": "set(android.content.Context,android.content.Intent,java.lang.Integer)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.setup": {
    "com.fsck.k9.setup.ServerNameSuggester": [
      {
        "visibility": "public",
        "simpleName": "suggestServerName(com.fsck.k9.mail.ServerSettings.Type,java.lang.String)",
        "qualifiedName": "com.fsck.k9.setup.ServerNameSuggester.suggestServerName(com.fsck.k9.mail.ServerSettings.Type,java.lang.String)",
        "kind": "method",
        "sourceText": "public java.lang.String suggestServerName(com.fsck.k9.mail.ServerSettings.Type serverType, java.lang.String domainPart) {\r\n    switch (serverType) {\r\n        case IMAP :\r\n            {\r\n                return \"imap.\" + domainPart;\r\n            }\r\n        case SMTP :\r\n            {\r\n                return \"smtp.\" + domainPart;\r\n            }\r\n        case WebDAV :\r\n            {\r\n                return \"exchange.\" + domainPart;\r\n            }\r\n        case POP3 :\r\n            {\r\n                return \"pop3.\" + domainPart;\r\n            }\r\n    }\r\n    throw new java.lang.AssertionError(\"Missed case: \" + serverType);\r\n}",
        "name": "suggestServerName(com.fsck.k9.mail.ServerSettings.Type,java.lang.String)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.ui": {
    "com.fsck.k9.ui.ContactBadge": [
      {
        "visibility": "public",
        "simpleName": "assignContactFromEmail(java.lang.String,boolean,android.os.Bundle)",
        "qualifiedName": "com.fsck.k9.ui.ContactBadge.assignContactFromEmail(java.lang.String,boolean,android.os.Bundle)",
        "kind": "method",
        "sourceText": "/**\r\n * Assign a contact based on an email address. This should only be used when\r\n * the contact's URI is not available, as an extra query will have to be\r\n * performed to lookup the URI based on the email.\r\n *\r\n * @param emailAddress\r\n * \t\tThe email address of the contact.\r\n * @param lazyLookup\r\n * \t\tIf this is true, the lookup query will not be performed\r\n * \t\tuntil this view is clicked.\r\n * @param extras\r\n * \t\tA bundle of extras to populate the contact edit page with if the contact\r\n * \t\tis not found and the user chooses to add the email address to an existing contact or\r\n * \t\tcreate a new contact. Uses the same string constants as those found in\r\n * \t\t{@link android.provider.ContactsContract.Intents.Insert}\r\n */\r\npublic void assignContactFromEmail(java.lang.String emailAddress, boolean lazyLookup, android.os.Bundle extras) {\r\n    contactEmail = emailAddress;\r\n    this.extras = extras;\r\n    if (!lazyLookup) {\r\n        queryHandler.startQuery(com.fsck.k9.ui.ContactBadge.TOKEN_EMAIL_LOOKUP, null, android.net.Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, android.net.Uri.encode(contactEmail)), com.fsck.k9.ui.ContactBadge.EMAIL_LOOKUP_PROJECTION, null, null, null);\r\n    } else {\r\n        contactUri = null;\r\n        onContactUriChanged();\r\n    }\r\n}",
        "name": "assignContactFromEmail(java.lang.String,boolean,android.os.Bundle)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "assignContactUri(android.net.Uri)",
        "qualifiedName": "com.fsck.k9.ui.ContactBadge.assignContactUri(android.net.Uri)",
        "kind": "method",
        "sourceText": "/**\r\n * Assign the contact uri that this ContactBadge should be associated\r\n * with. Note that this is only used for displaying the QuickContact window and\r\n * won't bind the contact's photo for you. Call {@link #setImageDrawable(Drawable)} to set the\r\n * photo.\r\n *\r\n * @param contactUri\r\n * \t\tEither a {@link Contacts#CONTENT_URI} or\r\n * \t\t{@link Contacts#CONTENT_LOOKUP_URI} style URI.\r\n */\r\npublic void assignContactUri(android.net.Uri contactUri) {\r\n    this.contactUri = contactUri;\r\n    contactEmail = null;\r\n    onContactUriChanged();\r\n}",
        "name": "assignContactUri(android.net.Uri)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onClick(android.view.View)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.ui.ContactBadge.onClick(android.view.View)",
        "sourceText": "@java.lang.Override\r\npublic void onClick(android.view.View v) {\r\n    // If contact has been assigned, extras should no longer be null, but do a null check\r\n    // anyway just in case assignContactFromPhone or Email was called with a null bundle or\r\n    // wasn't assigned previously.\r\n    final android.os.Bundle extras = (this.extras == null) ? new android.os.Bundle() : this.extras;\r\n    if (contactUri != null) {\r\n        android.provider.ContactsContract.QuickContact.showQuickContact(getContext(), this, contactUri, QuickContact.MODE_LARGE, null);\r\n    } else if (contactEmail != null) {\r\n        extras.putString(com.fsck.k9.ui.ContactBadge.EXTRA_URI_CONTENT, contactEmail);\r\n        queryHandler.startQuery(com.fsck.k9.ui.ContactBadge.TOKEN_EMAIL_LOOKUP_AND_TRIGGER, extras, android.net.Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, android.net.Uri.encode(contactEmail)), com.fsck.k9.ui.ContactBadge.EMAIL_LOOKUP_PROJECTION, null, null, null);\r\n    }\r\n}",
        "name": "onClick(android.view.View)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "assignContactFromEmail(java.lang.String,boolean)",
        "qualifiedName": "com.fsck.k9.ui.ContactBadge.assignContactFromEmail(java.lang.String,boolean)",
        "kind": "method",
        "sourceText": "/**\r\n * Assign a contact based on an email address. This should only be used when\r\n * the contact's URI is not available, as an extra query will have to be\r\n * performed to lookup the URI based on the email.\r\n *\r\n * @param emailAddress\r\n * \t\tThe email address of the contact.\r\n * @param lazyLookup\r\n * \t\tIf this is true, the lookup query will not be performed\r\n * \t\tuntil this view is clicked.\r\n */\r\npublic void assignContactFromEmail(java.lang.String emailAddress, boolean lazyLookup) {\r\n    assignContactFromEmail(emailAddress, lazyLookup, null);\r\n}",
        "name": "assignContactFromEmail(java.lang.String,boolean)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.ui.EolConvertingEditText": []
  },
  "com.fsck.k9.ui.compose": {
    "com.fsck.k9.ui.compose.QuotedMessageMvpView": [
      {
        "visibility": "public",
        "simpleName": "setOnClickPresenter(com.fsck.k9.ui.compose.QuotedMessagePresenter)",
        "qualifiedName": "com.fsck.k9.ui.compose.QuotedMessageMvpView.setOnClickPresenter(com.fsck.k9.ui.compose.QuotedMessagePresenter)",
        "kind": "method",
        "sourceText": "public void setOnClickPresenter(final com.fsck.k9.ui.compose.QuotedMessagePresenter presenter) {\r\n    android.view.View.OnClickListener onClickListener = new android.view.View.OnClickListener() {\r\n        @java.lang.Override\r\n        public void onClick(android.view.View view) {\r\n            switch (view.getId()) {\r\n                case R.id.quoted_text_show :\r\n                    presenter.onClickShowQuotedText();\r\n                    break;\r\n                case R.id.quoted_text_delete :\r\n                    presenter.onClickDeleteQuotedText();\r\n                    break;\r\n                case R.id.quoted_text_edit :\r\n                    presenter.onClickEditQuotedText();\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n    mQuotedTextShow.setOnClickListener(onClickListener);\r\n    mQuotedTextEdit.setOnClickListener(onClickListener);\r\n    mQuotedTextDelete.setOnClickListener(onClickListener);\r\n}",
        "name": "setOnClickPresenter(com.fsck.k9.ui.compose.QuotedMessagePresenter)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "showOrHideQuotedText(com.fsck.k9.message.QuotedTextMode,com.fsck.k9.message.SimpleMessageFormat)",
        "qualifiedName": "com.fsck.k9.ui.compose.QuotedMessageMvpView.showOrHideQuotedText(com.fsck.k9.message.QuotedTextMode,com.fsck.k9.message.SimpleMessageFormat)",
        "kind": "method",
        "sourceText": "public void showOrHideQuotedText(com.fsck.k9.message.QuotedTextMode mode, com.fsck.k9.message.SimpleMessageFormat quotedTextFormat) {\r\n    switch (mode) {\r\n        case NONE :\r\n            {\r\n                mQuotedTextShow.setVisibility(View.GONE);\r\n                mQuotedTextBar.setVisibility(View.GONE);\r\n                mQuotedText.setVisibility(View.GONE);\r\n                mQuotedHTML.setVisibility(View.GONE);\r\n                mQuotedTextEdit.setVisibility(View.GONE);\r\n                break;\r\n            }\r\n        case HIDE :\r\n            {\r\n                mQuotedTextShow.setVisibility(View.VISIBLE);\r\n                mQuotedTextBar.setVisibility(View.GONE);\r\n                mQuotedText.setVisibility(View.GONE);\r\n                mQuotedHTML.setVisibility(View.GONE);\r\n                mQuotedTextEdit.setVisibility(View.GONE);\r\n                break;\r\n            }\r\n        case SHOW :\r\n            {\r\n                mQuotedTextShow.setVisibility(View.GONE);\r\n                mQuotedTextBar.setVisibility(View.VISIBLE);\r\n                if (quotedTextFormat == com.fsck.k9.message.SimpleMessageFormat.HTML) {\r\n                    mQuotedText.setVisibility(View.GONE);\r\n                    mQuotedHTML.setVisibility(View.VISIBLE);\r\n                    mQuotedTextEdit.setVisibility(View.VISIBLE);\r\n                } else {\r\n                    mQuotedText.setVisibility(View.VISIBLE);\r\n                    mQuotedHTML.setVisibility(View.GONE);\r\n                    mQuotedTextEdit.setVisibility(View.GONE);\r\n                }\r\n                break;\r\n            }\r\n    }\r\n}",
        "name": "showOrHideQuotedText(com.fsck.k9.message.QuotedTextMode,com.fsck.k9.message.SimpleMessageFormat)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.ui.compose.QuotedMessagePresenter": [
      {
        "visibility": "public",
        "simpleName": "onRestoreInstanceState(android.os.Bundle)",
        "qualifiedName": "com.fsck.k9.ui.compose.QuotedMessagePresenter.onRestoreInstanceState(android.os.Bundle)",
        "kind": "method",
        "sourceText": "public void onRestoreInstanceState(android.os.Bundle savedInstanceState) {\r\n    quotedHtmlContent = ((com.fsck.k9.message.quote.InsertableHtmlContent) (savedInstanceState.getSerializable(com.fsck.k9.ui.compose.QuotedMessagePresenter.STATE_KEY_HTML_QUOTE)));\r\n    if ((quotedHtmlContent != null) && (quotedHtmlContent.getQuotedContent() != null)) {\r\n        // we don't have the part here, but inline-displayed images are cached by the webview\r\n        view.setQuotedHtml(quotedHtmlContent.getQuotedContent(), null);\r\n    }\r\n    quotedTextFormat = ((com.fsck.k9.message.SimpleMessageFormat) (savedInstanceState.getSerializable(com.fsck.k9.ui.compose.QuotedMessagePresenter.STATE_KEY_QUOTED_TEXT_FORMAT)));\r\n    forcePlainText = savedInstanceState.getBoolean(com.fsck.k9.ui.compose.QuotedMessagePresenter.STATE_KEY_FORCE_PLAIN_TEXT);\r\n    showOrHideQuotedText(((com.fsck.k9.message.QuotedTextMode) (savedInstanceState.getSerializable(com.fsck.k9.ui.compose.QuotedMessagePresenter.STATE_KEY_QUOTED_TEXT_MODE))));\r\n}",
        "name": "onRestoreInstanceState(android.os.Bundle)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "processMessageToForward(com.fsck.k9.mailstore.MessageViewInfo)",
        "qualifiedName": "com.fsck.k9.ui.compose.QuotedMessagePresenter.processMessageToForward(com.fsck.k9.mailstore.MessageViewInfo)",
        "kind": "method",
        "sourceText": "public void processMessageToForward(com.fsck.k9.mailstore.MessageViewInfo messageViewInfo) throws com.fsck.k9.mail.MessagingException {\r\n    quoteStyle = com.fsck.k9.Account.QuoteStyle.HEADER;\r\n    populateUIWithQuotedMessage(messageViewInfo, true, com.fsck.k9.activity.MessageCompose.Action.FORWARD);\r\n}",
        "name": "processMessageToForward(com.fsck.k9.mailstore.MessageViewInfo)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onSaveInstanceState(android.os.Bundle)",
        "qualifiedName": "com.fsck.k9.ui.compose.QuotedMessagePresenter.onSaveInstanceState(android.os.Bundle)",
        "kind": "method",
        "sourceText": "public void onSaveInstanceState(android.os.Bundle outState) {\r\n    outState.putSerializable(com.fsck.k9.ui.compose.QuotedMessagePresenter.STATE_KEY_QUOTED_TEXT_MODE, quotedTextMode);\r\n    outState.putSerializable(com.fsck.k9.ui.compose.QuotedMessagePresenter.STATE_KEY_HTML_QUOTE, quotedHtmlContent);\r\n    outState.putSerializable(com.fsck.k9.ui.compose.QuotedMessagePresenter.STATE_KEY_QUOTED_TEXT_FORMAT, quotedTextFormat);\r\n    outState.putBoolean(com.fsck.k9.ui.compose.QuotedMessagePresenter.STATE_KEY_FORCE_PLAIN_TEXT, forcePlainText);\r\n}",
        "name": "onSaveInstanceState(android.os.Bundle)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "builderSetProperties(com.fsck.k9.message.MessageBuilder)",
        "qualifiedName": "com.fsck.k9.ui.compose.QuotedMessagePresenter.builderSetProperties(com.fsck.k9.message.MessageBuilder)",
        "kind": "method",
        "sourceText": "public void builderSetProperties(com.fsck.k9.message.MessageBuilder builder) {\r\n    // TODO avoid using a getter from the view!\r\n    builder.setQuoteStyle(quoteStyle).setQuotedText(view.getQuotedText()).setQuotedTextMode(quotedTextMode).setQuotedHtmlContent(quotedHtmlContent).setReplyAfterQuote(account.isReplyAfterQuote());\r\n}",
        "name": "builderSetProperties(com.fsck.k9.message.MessageBuilder)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.ui.crypto": {
    "com.fsck.k9.ui.crypto.MessageCryptoHelper": [
      {
        "visibility": "public",
        "simpleName": "asyncStartOrResumeProcessingMessage(com.fsck.k9.mail.Message,com.fsck.k9.ui.crypto.MessageCryptoCallback,org.openintents.openpgp.OpenPgpDecryptionResult,boolean)",
        "qualifiedName": "com.fsck.k9.ui.crypto.MessageCryptoHelper.asyncStartOrResumeProcessingMessage(com.fsck.k9.mail.Message,com.fsck.k9.ui.crypto.MessageCryptoCallback,org.openintents.openpgp.OpenPgpDecryptionResult,boolean)",
        "kind": "method",
        "sourceText": "public void asyncStartOrResumeProcessingMessage(com.fsck.k9.mail.Message message, com.fsck.k9.ui.crypto.MessageCryptoCallback callback, org.openintents.openpgp.OpenPgpDecryptionResult cachedDecryptionResult, boolean processSignedOnly) {\r\n    if (this.currentMessage != null) {\r\n        reattachCallback(message, callback);\r\n        return;\r\n    }\r\n    this.messageAnnotations = new com.fsck.k9.ui.crypto.MessageCryptoAnnotations();\r\n    this.state = com.fsck.k9.ui.crypto.MessageCryptoHelper.State.START;\r\n    this.currentMessage = message;\r\n    this.cachedDecryptionResult = cachedDecryptionResult;\r\n    this.callback = callback;\r\n    this.processSignedOnly = processSignedOnly;\r\n    nextStep();\r\n}",
        "name": "asyncStartOrResumeProcessingMessage(com.fsck.k9.mail.Message,com.fsck.k9.ui.crypto.MessageCryptoCallback,org.openintents.openpgp.OpenPgpDecryptionResult,boolean)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onActivityResult(int,int,android.content.Intent)",
        "qualifiedName": "com.fsck.k9.ui.crypto.MessageCryptoHelper.onActivityResult(int,int,android.content.Intent)",
        "kind": "method",
        "sourceText": "public void onActivityResult(int requestCode, int resultCode, android.content.Intent data) {\r\n    if (isCancelled) {\r\n        return;\r\n    }\r\n    if (requestCode != com.fsck.k9.ui.crypto.MessageCryptoHelper.REQUEST_CODE_USER_INTERACTION) {\r\n        throw new java.lang.IllegalStateException(\"got an activity result that wasn't meant for us. this is a bug!\");\r\n    }\r\n    if (resultCode == android.app.Activity.RESULT_OK) {\r\n        userInteractionResultIntent = data;\r\n        nextStep();\r\n    } else {\r\n        onCryptoOperationCanceled();\r\n    }\r\n}",
        "name": "onActivityResult(int,int,android.content.Intent)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.ui.crypto.MessageCryptoCallback": [],
    "com.fsck.k9.ui.crypto.MessageCryptoAnnotations": [
      {
        "visibility": "public",
        "simpleName": "findKeyForAnnotationWithReplacementPart(com.fsck.k9.mail.Part)",
        "qualifiedName": "com.fsck.k9.ui.crypto.MessageCryptoAnnotations.findKeyForAnnotationWithReplacementPart(com.fsck.k9.mail.Part)",
        "kind": "method",
        "sourceText": "public com.fsck.k9.mail.Part findKeyForAnnotationWithReplacementPart(com.fsck.k9.mail.Part part) {\r\n    for (java.util.Map.Entry<com.fsck.k9.mail.Part, com.fsck.k9.mailstore.CryptoResultAnnotation> entry : annotations.entrySet()) {\r\n        if (part == entry.getValue().getReplacementData()) {\r\n            return entry.getKey();\r\n        }\r\n    }\r\n    return null;\r\n}",
        "name": "findKeyForAnnotationWithReplacementPart(com.fsck.k9.mail.Part)",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.ui.dialog": {
    "com.fsck.k9.ui.dialog.ApgDeprecationWarningDialog": []
  },
  "com.fsck.k9.ui.message": {
    "com.fsck.k9.ui.message.LocalMessageLoader": [],
    "com.fsck.k9.ui.message.LocalMessageExtractorLoader": [
      {
        "visibility": "public",
        "simpleName": "loadInBackground()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.ui.message.LocalMessageExtractorLoader.loadInBackground()",
        "sourceText": "@java.lang.Override\r\n@android.support.annotation.WorkerThread\r\npublic com.fsck.k9.mailstore.MessageViewInfo loadInBackground() {\r\n    try {\r\n        return com.fsck.k9.ui.message.LocalMessageExtractorLoader.messageViewInfoExtractor.extractMessageForView(message, annotations);\r\n    } catch (java.lang.Exception e) {\r\n        timber.log.Timber.e(e, \"Error while decoding message\");\r\n        return null;\r\n    }\r\n}",
        "name": "loadInBackground()",
        "metaSrc": "source code"
      }
    ]
  },
  "com.fsck.k9.ui.messageview": {
    "com.fsck.k9.ui.messageview.MessageViewFragment": [
      {
        "visibility": "public",
        "simpleName": "onDestroy()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.ui.messageview.MessageViewFragment.onDestroy()",
        "sourceText": "@java.lang.Override\r\npublic void onDestroy() {\r\n    super.onDestroy();\r\n    android.app.Activity activity = getActivity();\r\n    boolean isChangingConfigurations = (activity != null) && activity.isChangingConfigurations();\r\n    if (isChangingConfigurations) {\r\n        messageLoaderHelper.onDestroyChangingConfigurations();\r\n        return;\r\n    }\r\n    messageLoaderHelper.onDestroy();\r\n}",
        "name": "onDestroy()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onActivityCreated(android.os.Bundle)",
        "qualifiedName": "com.fsck.k9.ui.messageview.MessageViewFragment.onActivityCreated(android.os.Bundle)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic void onActivityCreated(android.os.Bundle savedInstanceState) {\r\n    super.onActivityCreated(savedInstanceState);\r\n    android.os.Bundle arguments = getArguments();\r\n    java.lang.String messageReferenceString = arguments.getString(com.fsck.k9.ui.messageview.MessageViewFragment.ARG_REFERENCE);\r\n    com.fsck.k9.activity.MessageReference messageReference = com.fsck.k9.activity.MessageReference.parse(messageReferenceString);\r\n    displayMessage(messageReference);\r\n}",
        "name": "onActivityCreated(android.os.Bundle)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "doPositiveClick(int)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.ui.messageview.MessageViewFragment.doPositiveClick(int)",
        "sourceText": "@java.lang.Override\r\npublic void doPositiveClick(int dialogId) {\r\n    switch (dialogId) {\r\n        case R.id.dialog_confirm_delete :\r\n            {\r\n                delete();\r\n                break;\r\n            }\r\n        case R.id.dialog_confirm_spam :\r\n            {\r\n                refileMessage(mDstFolder);\r\n                mDstFolder = null;\r\n                break;\r\n            }\r\n    }\r\n}",
        "name": "doPositiveClick(int)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "newInstance(com.fsck.k9.activity.MessageReference)",
        "qualifiedName": "com.fsck.k9.ui.messageview.MessageViewFragment.newInstance(com.fsck.k9.activity.MessageReference)",
        "kind": "method",
        "sourceText": "public static com.fsck.k9.ui.messageview.MessageViewFragment newInstance(com.fsck.k9.activity.MessageReference reference) {\r\n    com.fsck.k9.ui.messageview.MessageViewFragment fragment = new com.fsck.k9.ui.messageview.MessageViewFragment();\r\n    android.os.Bundle args = new android.os.Bundle();\r\n    args.putString(com.fsck.k9.ui.messageview.MessageViewFragment.ARG_REFERENCE, reference.toIdentityString());\r\n    fragment.setArguments(args);\r\n    return fragment;\r\n}",
        "name": "newInstance(com.fsck.k9.activity.MessageReference)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onPendingIntentResult(int,int,android.content.Intent)",
        "qualifiedName": "com.fsck.k9.ui.messageview.MessageViewFragment.onPendingIntentResult(int,int,android.content.Intent)",
        "kind": "method",
        "sourceText": "public void onPendingIntentResult(int requestCode, int resultCode, android.content.Intent data) {\r\n    if ((requestCode & com.fsck.k9.ui.messageview.MessageViewFragment.REQUEST_MASK_LOADER_HELPER) == com.fsck.k9.ui.messageview.MessageViewFragment.REQUEST_MASK_LOADER_HELPER) {\r\n        requestCode ^= com.fsck.k9.ui.messageview.MessageViewFragment.REQUEST_MASK_LOADER_HELPER;\r\n        messageLoaderHelper.onActivityResult(requestCode, resultCode, data);\r\n        return;\r\n    }\r\n    if ((requestCode & com.fsck.k9.ui.messageview.MessageViewFragment.REQUEST_MASK_CRYPTO_PRESENTER) == com.fsck.k9.ui.messageview.MessageViewFragment.REQUEST_MASK_CRYPTO_PRESENTER) {\r\n        requestCode ^= com.fsck.k9.ui.messageview.MessageViewFragment.REQUEST_MASK_CRYPTO_PRESENTER;\r\n        messageCryptoPresenter.onActivityResult(requestCode, resultCode, data);\r\n    }\r\n}",
        "name": "onPendingIntentResult(int,int,android.content.Intent)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onRefile(java.lang.String)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.ui.messageview.MessageViewFragment.onRefile(java.lang.String)",
        "sourceText": "public void onRefile(java.lang.String dstFolder) {\r\n    if (!mController.isMoveCapable(mAccount)) {\r\n        return;\r\n    }\r\n    if (!mController.isMoveCapable(mMessageReference)) {\r\n        android.widget.Toast toast = android.widget.Toast.makeText(getActivity(), R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);\r\n        toast.show();\r\n        return;\r\n    }\r\n    if (com.fsck.k9.K9.FOLDER_NONE.equalsIgnoreCase(dstFolder)) {\r\n        return;\r\n    }\r\n    if (mAccount.getSpamFolderName().equals(dstFolder) && com.fsck.k9.K9.confirmSpam()) {\r\n        mDstFolder = dstFolder;\r\n        showDialog(R.id.dialog_confirm_spam);\r\n    } else {\r\n        refileMessage(dstFolder);\r\n    }\r\n}",
        "name": "onRefile(java.lang.String)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onToggleRead()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.ui.messageview.MessageViewFragment.onToggleRead()",
        "sourceText": "public void onToggleRead() {\r\n    if (mMessage != null) {\r\n        mController.setFlag(mAccount, mMessage.getFolder().getName(), java.util.Collections.singletonList(mMessage), Flag.SEEN, !mMessage.isSet(Flag.SEEN));\r\n        mMessageView.setHeaders(mMessage, mAccount);\r\n        java.lang.String subject = mMessage.getSubject();\r\n        displayMessageSubject(subject);\r\n        mFragmentListener.updateMenu();\r\n    }\r\n}",
        "name": "onToggleRead()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onCreate(android.os.Bundle)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.ui.messageview.MessageViewFragment.onCreate(android.os.Bundle)",
        "sourceText": "@java.lang.Override\r\npublic void onCreate(android.os.Bundle savedInstanceState) {\r\n    super.onCreate(savedInstanceState);\r\n    // This fragments adds options to the action bar\r\n    setHasOptionsMenu(true);\r\n    android.content.Context context = getActivity().getApplicationContext();\r\n    mController = com.fsck.k9.controller.MessagingController.getInstance(context);\r\n    downloadManager = ((android.app.DownloadManager) (context.getSystemService(Context.DOWNLOAD_SERVICE)));\r\n    messageCryptoPresenter = new com.fsck.k9.ui.messageview.MessageCryptoPresenter(savedInstanceState, messageCryptoMvpView);\r\n    messageLoaderHelper = new com.fsck.k9.activity.MessageLoaderHelper(context, getLoaderManager(), getFragmentManager(), messageLoaderCallbacks);\r\n    mInitialized = true;\r\n}",
        "name": "onCreate(android.os.Bundle)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onCopy()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.ui.messageview.MessageViewFragment.onCopy()",
        "sourceText": "public void onCopy() {\r\n    if ((!mController.isCopyCapable(mAccount)) || (mMessage == null)) {\r\n        return;\r\n    }\r\n    if (!mController.isCopyCapable(mMessageReference)) {\r\n        android.widget.Toast toast = android.widget.Toast.makeText(getActivity(), R.string.move_copy_cannot_copy_unsynced_message, Toast.LENGTH_LONG);\r\n        toast.show();\r\n        return;\r\n    }\r\n    startRefileActivity(com.fsck.k9.ui.messageview.MessageViewFragment.ACTIVITY_CHOOSE_FOLDER_COPY);\r\n}",
        "name": "onCopy()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle)",
        "qualifiedName": "com.fsck.k9.ui.messageview.MessageViewFragment.onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic android.view.View onCreateView(android.view.LayoutInflater inflater, android.view.ViewGroup container, android.os.Bundle savedInstanceState) {\r\n    android.content.Context context = new android.view.ContextThemeWrapper(inflater.getContext(), com.fsck.k9.K9.getK9ThemeResourceId(com.fsck.k9.K9.getK9MessageViewTheme()));\r\n    android.view.LayoutInflater layoutInflater = android.view.LayoutInflater.from(context);\r\n    android.view.View view = layoutInflater.inflate(R.layout.message, container, false);\r\n    mMessageView = ((com.fsck.k9.ui.messageview.MessageTopView) (view.findViewById(R.id.message_view)));\r\n    mMessageView.setAttachmentCallback(this);\r\n    mMessageView.setMessageCryptoPresenter(messageCryptoPresenter);\r\n    mMessageView.setOnToggleFlagClickListener(new android.view.View.OnClickListener() {\r\n        @java.lang.Override\r\n        public void onClick(android.view.View v) {\r\n            onToggleFlagged();\r\n        }\r\n    });\r\n    mMessageView.setOnDownloadButtonClickListener(new android.view.View.OnClickListener() {\r\n        @java.lang.Override\r\n        public void onClick(android.view.View v) {\r\n            mMessageView.disableDownloadButton();\r\n            messageLoaderHelper.downloadCompleteMessage();\r\n        }\r\n    });\r\n    mFragmentListener.messageHeaderViewAvailable(mMessageView.getMessageHeaderView());\r\n    return view;\r\n}",
        "name": "onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.ui.messageview.MessageContainerView": [
      {
        "visibility": "public",
        "simpleName": "renderAttachments(com.fsck.k9.mailstore.MessageViewInfo)",
        "qualifiedName": "com.fsck.k9.ui.messageview.MessageContainerView.renderAttachments(com.fsck.k9.mailstore.MessageViewInfo)",
        "kind": "method",
        "sourceText": "public void renderAttachments(com.fsck.k9.mailstore.MessageViewInfo messageViewInfo) {\r\n    if (messageViewInfo.attachments != null) {\r\n        for (com.fsck.k9.mailstore.AttachmentViewInfo attachment : messageViewInfo.attachments) {\r\n            attachments.put(attachment.internalUri, attachment);\r\n            if (attachment.inlineAttachment) {\r\n                continue;\r\n            }\r\n            com.fsck.k9.ui.messageview.AttachmentView view = ((com.fsck.k9.ui.messageview.AttachmentView) (mInflater.inflate(R.layout.message_view_attachment, mAttachments, false)));\r\n            view.setCallback(attachmentCallback);\r\n            view.setAttachment(attachment);\r\n            attachmentViewMap.put(attachment, view);\r\n            mAttachments.addView(view);\r\n        }\r\n    }\r\n    if (messageViewInfo.extraAttachments != null) {\r\n        for (com.fsck.k9.mailstore.AttachmentViewInfo attachment : messageViewInfo.extraAttachments) {\r\n            attachments.put(attachment.internalUri, attachment);\r\n            if (attachment.inlineAttachment) {\r\n                continue;\r\n            }\r\n            com.fsck.k9.ui.messageview.LockedAttachmentView view = ((com.fsck.k9.ui.messageview.LockedAttachmentView) (mInflater.inflate(R.layout.message_view_attachment_locked, mAttachments, false)));\r\n            view.setCallback(attachmentCallback);\r\n            view.setAttachment(attachment);\r\n            // attachments.put(attachment, view);\r\n            mAttachments.addView(view);\r\n        }\r\n    }\r\n}",
        "name": "renderAttachments(com.fsck.k9.mailstore.MessageViewInfo)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "resetView()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.ui.messageview.MessageContainerView.resetView()",
        "sourceText": "public void resetView() {\r\n    setLoadPictures(false);\r\n    mAttachments.removeAllViews();\r\n    currentHtmlText = null;\r\n    currentAttachmentResolver = null;\r\n    /* Clear the WebView content\n\n    For some reason WebView.clearView() doesn't clear the contents when the WebView changes\n    its size because the button to download the complete message was previously shown and\n    is now hidden.\n     */\r\n    clearDisplayedContent();\r\n}",
        "name": "resetView()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onFinishInflate()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.ui.messageview.MessageContainerView.onFinishInflate()",
        "sourceText": "@java.lang.Override\r\npublic void onFinishInflate() {\r\n    super.onFinishInflate();\r\n    mMessageContentView = ((com.fsck.k9.view.MessageWebView) (findViewById(R.id.message_content)));\r\n    if (!isInEditMode()) {\r\n        mMessageContentView.configure();\r\n    }\r\n    mMessageContentView.setOnCreateContextMenuListener(this);\r\n    mMessageContentView.setVisibility(View.VISIBLE);\r\n    mAttachmentsContainer = findViewById(R.id.attachments_container);\r\n    mAttachments = ((android.widget.LinearLayout) (findViewById(R.id.attachments)));\r\n    unsignedTextContainer = findViewById(R.id.message_unsigned_container);\r\n    unsignedTextDivider = findViewById(R.id.message_unsigned_divider);\r\n    unsignedText = ((android.widget.TextView) (findViewById(R.id.message_unsigned_text)));\r\n    showingPictures = false;\r\n    android.content.Context context = getContext();\r\n    mInflater = android.view.LayoutInflater.from(context);\r\n    mClipboardManager = com.fsck.k9.helper.ClipboardManager.getInstance(context);\r\n}",
        "name": "onFinishInflate()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onRestoreInstanceState(android.os.Parcelable)",
        "qualifiedName": "com.fsck.k9.ui.messageview.MessageContainerView.onRestoreInstanceState(android.os.Parcelable)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic void onRestoreInstanceState(android.os.Parcelable state) {\r\n    if (!(state instanceof com.fsck.k9.ui.messageview.MessageContainerView.SavedState)) {\r\n        super.onRestoreInstanceState(state);\r\n        return;\r\n    }\r\n    com.fsck.k9.ui.messageview.MessageContainerView.SavedState savedState = ((com.fsck.k9.ui.messageview.MessageContainerView.SavedState) (state));\r\n    super.onRestoreInstanceState(savedState.getSuperState());\r\n    mSavedState = savedState;\r\n}",
        "name": "onRestoreInstanceState(android.os.Parcelable)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "displayMessageViewContainer(com.fsck.k9.mailstore.MessageViewInfo,com.fsck.k9.ui.messageview.MessageContainerView$OnRenderingFinishedListener,boolean,boolean,com.fsck.k9.ui.messageview.AttachmentViewCallback)",
        "qualifiedName": "com.fsck.k9.ui.messageview.MessageContainerView.displayMessageViewContainer(com.fsck.k9.mailstore.MessageViewInfo,com.fsck.k9.ui.messageview.MessageContainerView$OnRenderingFinishedListener,boolean,boolean,com.fsck.k9.ui.messageview.AttachmentViewCallback)",
        "kind": "method",
        "sourceText": "public void displayMessageViewContainer(com.fsck.k9.mailstore.MessageViewInfo messageViewInfo, final com.fsck.k9.ui.messageview.MessageContainerView.OnRenderingFinishedListener onRenderingFinishedListener, boolean automaticallyLoadPictures, boolean hideUnsignedTextDivider, com.fsck.k9.ui.messageview.AttachmentViewCallback attachmentCallback) {\r\n    this.attachmentCallback = attachmentCallback;\r\n    resetView();\r\n    renderAttachments(messageViewInfo);\r\n    if (mSavedState != null) {\r\n        if (mSavedState.showingPictures) {\r\n            setLoadPictures(true);\r\n        }\r\n        mSavedState = null;\r\n    }\r\n    java.lang.String textToDisplay = messageViewInfo.text;\r\n    if ((textToDisplay != null) && (!isShowingPictures())) {\r\n        if (com.fsck.k9.helper.Utility.hasExternalImages(textToDisplay)) {\r\n            if (automaticallyLoadPictures) {\r\n                setLoadPictures(true);\r\n            } else {\r\n                hasHiddenExternalImages = true;\r\n            }\r\n        }\r\n    }\r\n    if (textToDisplay == null) {\r\n        textToDisplay = com.fsck.k9.message.html.HtmlConverter.wrapStatusMessage(getContext().getString(R.string.webview_empty_message));\r\n    }\r\n    com.fsck.k9.view.MessageWebView.OnPageFinishedListener onPageFinishedListener = new com.fsck.k9.view.MessageWebView.OnPageFinishedListener() {\r\n        @java.lang.Override\r\n        public void onPageFinished() {\r\n            onRenderingFinishedListener.onLoadFinished();\r\n        }\r\n    };\r\n    displayHtmlContentWithInlineAttachments(textToDisplay, messageViewInfo.attachmentResolver, onPageFinishedListener);\r\n    if (!android.text.TextUtils.isEmpty(messageViewInfo.extraText)) {\r\n        unsignedTextContainer.setVisibility(View.VISIBLE);\r\n        unsignedTextDivider.setVisibility(hideUnsignedTextDivider ? android.view.View.GONE : android.view.View.VISIBLE);\r\n        unsignedText.setText(messageViewInfo.extraText);\r\n    }\r\n}",
        "name": "displayMessageViewContainer(com.fsck.k9.mailstore.MessageViewInfo,com.fsck.k9.ui.messageview.MessageContainerView$OnRenderingFinishedListener,boolean,boolean,com.fsck.k9.ui.messageview.AttachmentViewCallback)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onSaveInstanceState()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.ui.messageview.MessageContainerView.onSaveInstanceState()",
        "sourceText": "@java.lang.Override\r\npublic android.os.Parcelable onSaveInstanceState() {\r\n    android.os.Parcelable superState = super.onSaveInstanceState();\r\n    com.fsck.k9.ui.messageview.MessageContainerView.SavedState savedState = new com.fsck.k9.ui.messageview.MessageContainerView.SavedState(superState);\r\n    savedState.attachmentViewVisible = (mAttachmentsContainer != null) && (mAttachmentsContainer.getVisibility() == android.view.View.VISIBLE);\r\n    savedState.showingPictures = showingPictures;\r\n    return savedState;\r\n}",
        "name": "onSaveInstanceState()",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.ui.messageview.AttachmentController": []
  },
  "com.fsck.k9.view": {
    "com.fsck.k9.view.HighlightDialogFragment": [],
    "com.fsck.k9.view.ToolableViewAnimator": [
      {
        "visibility": "public",
        "simpleName": "setDisplayedChildId(int)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.view.ToolableViewAnimator.setDisplayedChildId(int)",
        "sourceText": "public void setDisplayedChildId(int id) {\r\n    if (getDisplayedChildId() == id) {\r\n        return;\r\n    }\r\n    for (int i = 0, count = getChildCount(); i < count; i++) {\r\n        if (getChildAt(i).getId() == id) {\r\n            setDisplayedChild(i);\r\n            return;\r\n        }\r\n    }\r\n    java.lang.String name = getResources().getResourceEntryName(id);\r\n    throw new java.lang.IllegalArgumentException(\"No view with ID \" + name);\r\n}",
        "name": "setDisplayedChildId(int)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "setDisplayedChild(int,boolean)",
        "qualifiedName": "com.fsck.k9.view.ToolableViewAnimator.setDisplayedChild(int,boolean)",
        "kind": "method",
        "sourceText": "public void setDisplayedChild(int whichChild, boolean animate) {\r\n    if (animate) {\r\n        setDisplayedChild(whichChild);\r\n        return;\r\n    }\r\n    android.view.animation.Animation savedInAnim = getInAnimation();\r\n    android.view.animation.Animation savedOutAnim = getOutAnimation();\r\n    setInAnimation(null);\r\n    setOutAnimation(null);\r\n    setDisplayedChild(whichChild);\r\n    setInAnimation(savedInAnim);\r\n    setOutAnimation(savedOutAnim);\r\n}",
        "name": "setDisplayedChild(int,boolean)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.view.ViewSwitcher": []
  },
  "com.fsck.k9.widget.list": {
    "com.fsck.k9.widget.list.MessageListRemoteViewFactory": [
      {
        "visibility": "public",
        "simpleName": "getLoadingView()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.widget.list.MessageListRemoteViewFactory.getLoadingView()",
        "sourceText": "@java.lang.Override\r\npublic android.widget.RemoteViews getLoadingView() {\r\n    android.widget.RemoteViews loadingView = new android.widget.RemoteViews(context.getPackageName(), R.layout.message_list_widget_loading);\r\n    loadingView.setTextViewText(R.id.loadingText, context.getString(R.string.mail_list_widget_loading));\r\n    loadingView.setViewVisibility(R.id.loadingText, View.VISIBLE);\r\n    return loadingView;\r\n}",
        "name": "getLoadingView()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onCreate()",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.widget.list.MessageListRemoteViewFactory.onCreate()",
        "sourceText": "@java.lang.Override\r\npublic void onCreate() {\r\n    senderAboveSubject = com.fsck.k9.K9.messageListSenderAboveSubject();\r\n    readTextColor = android.support.v4.content.ContextCompat.getColor(context, R.color.message_list_widget_text_read);\r\n    unreadTextColor = android.support.v4.content.ContextCompat.getColor(context, R.color.message_list_widget_text_unread);\r\n}",
        "name": "onCreate()",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "getViewAt(int)",
        "kind": "method",
        "qualifiedName": "com.fsck.k9.widget.list.MessageListRemoteViewFactory.getViewAt(int)",
        "sourceText": "@java.lang.Override\r\npublic android.widget.RemoteViews getViewAt(int position) {\r\n    android.widget.RemoteViews remoteView = new android.widget.RemoteViews(context.getPackageName(), R.layout.message_list_widget_list_item);\r\n    com.fsck.k9.widget.list.MessageListRemoteViewFactory.MailItem item = mailItems.get(position);\r\n    java.lang.CharSequence sender = (item.unread) ? bold(item.sender) : item.sender;\r\n    java.lang.CharSequence subject = (item.unread) ? bold(item.subject) : item.subject;\r\n    if (senderAboveSubject) {\r\n        remoteView.setTextViewText(R.id.sender, sender);\r\n        remoteView.setTextViewText(R.id.mail_subject, subject);\r\n    } else {\r\n        remoteView.setTextViewText(R.id.sender, subject);\r\n        remoteView.setTextViewText(R.id.mail_subject, sender);\r\n    }\r\n    remoteView.setTextViewText(R.id.mail_date, item.getDateFormatted(\"%d %s\"));\r\n    remoteView.setTextViewText(R.id.mail_preview, item.preview);\r\n    int textColor = item.getTextColor();\r\n    remoteView.setTextColor(R.id.sender, textColor);\r\n    remoteView.setTextColor(R.id.mail_subject, textColor);\r\n    remoteView.setTextColor(R.id.mail_date, textColor);\r\n    remoteView.setTextColor(R.id.mail_preview, textColor);\r\n    if (item.hasAttachment) {\r\n        remoteView.setInt(R.id.attachment, \"setVisibility\", View.VISIBLE);\r\n    } else {\r\n        remoteView.setInt(R.id.attachment, \"setVisibility\", View.GONE);\r\n    }\r\n    android.content.Intent intent = new android.content.Intent();\r\n    intent.setData(item.uri);\r\n    remoteView.setOnClickFillInIntent(R.id.mail_list_item, intent);\r\n    return remoteView;\r\n}",
        "name": "getViewAt(int)",
        "metaSrc": "source code"
      }
    ],
    "com.fsck.k9.widget.list.MessageListWidgetService": [],
    "com.fsck.k9.widget.list.MessageListWidgetProvider": [
      {
        "visibility": "public",
        "simpleName": "triggerMessageListWidgetUpdate(android.content.Context)",
        "qualifiedName": "com.fsck.k9.widget.list.MessageListWidgetProvider.triggerMessageListWidgetUpdate(android.content.Context)",
        "kind": "method",
        "sourceText": "public static void triggerMessageListWidgetUpdate(android.content.Context context) {\r\n    android.content.Context appContext = context.getApplicationContext();\r\n    android.appwidget.AppWidgetManager widgetManager = android.appwidget.AppWidgetManager.getInstance(appContext);\r\n    android.content.ComponentName widget = new android.content.ComponentName(appContext, com.fsck.k9.widget.list.MessageListWidgetProvider.class);\r\n    int[] widgetIds = widgetManager.getAppWidgetIds(widget);\r\n    android.content.Intent intent = new android.content.Intent(context, com.fsck.k9.widget.list.MessageListWidgetProvider.class);\r\n    intent.setAction(com.fsck.k9.widget.list.MessageListWidgetProvider.ACTION_UPDATE_MESSAGE_LIST);\r\n    intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, widgetIds);\r\n    context.sendBroadcast(intent);\r\n}",
        "name": "triggerMessageListWidgetUpdate(android.content.Context)",
        "metaSrc": "source code"
      },
      {
        "visibility": "public",
        "simpleName": "onReceive(android.content.Context,android.content.Intent)",
        "qualifiedName": "com.fsck.k9.widget.list.MessageListWidgetProvider.onReceive(android.content.Context,android.content.Intent)",
        "kind": "method",
        "sourceText": "@java.lang.Override\r\npublic void onReceive(android.content.Context context, android.content.Intent intent) {\r\n    super.onReceive(context, intent);\r\n    java.lang.String action = intent.getAction();\r\n    if (action.equals(com.fsck.k9.widget.list.MessageListWidgetProvider.ACTION_UPDATE_MESSAGE_LIST)) {\r\n        android.appwidget.AppWidgetManager appWidgetManager = android.appwidget.AppWidgetManager.getInstance(context);\r\n        int[] appWidgetIds = intent.getIntArrayExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS);\r\n        appWidgetManager.notifyAppWidgetViewDataChanged(appWidgetIds, R.id.listView);\r\n    }\r\n}",
        "name": "onReceive(android.content.Context,android.content.Intent)",
        "metaSrc": "source code"
      }
    ]
  }
}